# k8s 클러스터 아키텍처

- 의문
- 개요
- 노드
  - 노드 상태
  - 하트비트
  - 노드 컨트롤러
  - 리소스 용량 추적
- 컨트롤 플레인-노드 간 통신

## 의문

## 개요

k8s의 컴포넌트

![](./images/cluster_architecture/components_of_k8s1.svg)

## 노드

- 개요
  - 팟내에 배치된 컨테이너를 실행하는 물리 / 가상 머신
- 특징
  - 컨트롤 플레인에 의해서 관리됨
  - 팟을 실행하는 데 필요한 컴포넌트 포함
    - **컨테이너 런타임, kubelet, kube-proxy**
  - 노드의 이름은 고유해야 함
- API서버에 노드 추가
  - 방법
    - 노드의 kubelet으로 컨트롤 플레인에 자체 등록
    - 사용자가 노드 오브젝트를 수동으로 추가
  - 순서
    - 위의 방법실행
    - k8s는 내부적으로 노드 오브젝트 생성
    - k8s는 노드의 `metadata.name`필드와 일치하는 API 서버에 등록이 되어있는지 확인
    - 노드의 상태
      - 정상이면 팟 실행 가능
      - 비정상이면 해당 노드는 정상이 될때까지 모든 클러스터 활동에 대해서 무시됨

### 노드 상태

`kubectl describe node <노드 이름>`으로 노드의 상태를 파악 가능

- 주소(Addresses)
  - HostName
    - 노드의 커널에 의해 알려진 호스트명
    - `--hostname-override` 파라미터를 통해 치환될 수 있음
  - ExternalIP
    - 노드의 IP주소는 외부로 라우트 가능(클러스터 외부에서 이용 가능)
  - InternalIP
    - 노드의 IP주소는 클러스터 내에서만 라우트 가능
- 컨디션(Conditions)
  - 개요
    - Running노드의 상태를 기술
  - 종류
    - `Ready`
      - `True`
        - 노드가 양호하며 팟을 수용할 준비가 되어있는 경우
      - `False`
        - 노드의 상태가 불량하여 팟을 수용하지 못할 경우
      - `Unknown`
        - 노드 컨트롤러가 마지막 `node-monitor-grace-period` (기본값 40)기간 동안 노드로부터 응답을 받지 못한 경우
          - *어떤 응답? 누가 대답하는거? kubelet*
    - `MemoryPressure`
      - 노드 메모리가 넉넉치 않은 경우
    - `DiskPressure`
      - 노드 디스크가 넉넉치 않은 경우
    - `PIDPressure`
      - 노드 상에 많은 프로세스들이 존재하는 경우(프로세스 상의 압박)
    - `NetworkUnavailable`
      - 노드에 대해 네트워크가 올바르게 구성되지 않은 경우
  - 특징
    - ready 컨디션의 status가 `pod-eviction-timeout`(default 5분)보다 더 길게 `Unknown`또는 `False`로 유지되는 경우, 노드 컨트롤러가 해동 노드에 할당된 전체 팟에 대해 API를 이용한 eviction을 트리거 함
      - taint가 아님
    - 노드에 접근이 불가할 떄와 같은 경우, API서버는 노드 상의 kubelet과 통신이 불가하여, API 서버와의 통신이 재개될 떄까지 팟 삭제에 대한 결정은 kubelet에 전해질 수 없음
      - 그 사이, 삭제되도록 스케줄된 팟은 분할된 노드 상에서 계속 동작할 수도 있음
    - 노드에 문제가 발생하면, 쿠버네티스 컨트롤 플레인은 자동으로 노드 상태에 영향을 주는 조건과 일치하는 테인트를 생성
    - 스케쥴러 팟을 노드에 할당할 때 노드의 테인트를 고려
- 용량과 할당가능(Capacity / Allocable)
  - 개요
    - 노드 상에 사용 가능한 리소스
      - CPU, 메모리, 노드상에 스케쥴 될 수 있는 최대 팟 수
    - 용량은 리소스 총량, 할당가능은 일반 팟에서 사용할 수 있는 노드의 리소스양
- 정보(System Info)
  - 커널 버전
  - 쿠버네티스 버전(kubelet, kube-proxy버전)
  - 컨테이너 런타임 상세 정보
  - 노드가 사용하는 운영체제
  - 특징
    - kubelet이 노드에서 수집하여 쿠버네티스 API로 전송

### 하트비트

- 개요
  - 크러스터가 개별 노드가 가용한지를 판단할 수 있도록 도움을 줌
- 종류
  - `.status`에 대한 업데이트
  - `kube-node-lease`네임스페이스 내의 리스 오브젝트. 각 노드는 연관된 리스 오브젝트를 갖음
    - `.status`에 비하면 경랑 리소스이며, 큰 클러스터에서는 리스를 하트비트에 사용하여 업데이트로인한 성능 영향 줄일 수 있음
- 특징
  - `kubelet`은 상태가 변경되거나 설정된 인터벌보다 오래 업데이트가 없는 경우, 노드의 `.status`를 업데이트 함. 노드의 `.status`업데이트에 대한 기본 인터벌은 접근이 불가능한 노드에 대한 타임아웃인 40초 보다 훨씬 긴 5분
  - kubelet은 리스 오브젝트를 (기본 업데이트 인터벌인) 매 10초마다 생성하고 업데이트한다. 리스 업데이트는 노드의 .status 업데이트와는 독립적이다. 만약 리스 업데이트가 실패하면, kubelet은 200밀리초에서 시작하고 7초의 상한을 갖는 지수적 백오프를 사용해서 재시도한다.

### 노드 컨트롤러

- 개요
  - 노드를 관리하는 쿠버네티스 컨트롤 플레인 컴포넌트
- 역할
  - 1 등록 시점에 노드에 CIDR블럭을 할당
  - 2 노드 컨트롤러의 내부 노드 리스트를 클라우드 제공사업자의 사용 가능한 머신 리스트 정보를 근거로 최신 상태로 유지
  - 3 노드 상태를 모니터링(5초마다)
    - 접근 불가능 상태가 되는 경우, `.status`필드의 `Ready`컨디션을 업데이트, 이 경우 `Unknown`으로
    - 노드가 접근 불가능 상태로 남아있는 경우, 노드의 모든 팟에 대해서 API를 이용한 축출을 트리거
      - `Unknown`으로 마킹한 뒤 5분을 기다렸다가 최초의 축출 요청을 시작

### 리소스 용량 추적

- 개요
  - 노드 오브젝트는 노드 리소스 용량에 대한 정보를 추적
    - 사용 가능한 CPU, 메모리 양
    - *오브젝트가 추적하는건가? 컨트롤러가 아니라? 그럼 여기서 말하는 오브젝트는 뭐지? 노드 자신?*
  - 쿠버네티스 스케줄러는 노드 상에 모든 노드에 대해 충분한 리소스가 존재하도록 보장
    - 스케줄러는 노드 상에 컨테이너에 대한 요청의 합이 노드 용량보다 더 크지 않도록 체크
    - 컨테이너 런타임에 의해 직접적으로 시작된 컨테이너와 kubelet 컨트롤 범위 밖에서 실행되는 모든 프로세스도 제외

## 컨트롤 플레인-노드 간 통신

### 노드에서 컨트롤 플레인으로의 통신

- 개요
  - 허브 앤 스포크 API패턴
    - 노드(또는 노드에서 실행되는 팟들)의 모든 API 사용은 API서버에서만 담당
    - 다른 컨트롤 플레인 컴포넌트 중 어느것도 원격 서비스를 노출하도록 설계되지 않음
  - 보안
    - HTTPS
    - 권한 부여
- 특징
  - **API 서버에 연결하려는 팟은 서비스 어카운트를 활용해서 안전하게 쿠버네티스가 공개 루트 인증서와 bearer token을 팟이 인스턴스화될 때 팟에 자동으로 주입 가능**

### 컨트롤 플레인에서 노드로의 통신

- API 서버에서 kubelet으로의 통신
  - 개요
    - 팟에 대한 로그가져오기
    - 실행중인 팟에 연결
    - kubelet 포트 포워딩 기능
  - 특징
    - kubelet의 인증서를 확인하지 않음
    - *SSH 터널링 가능*
- API 서버에서 노드, 팟 및 서비스로의 통신
  - 개요
  - 특징
    - HTTP연결
    - HTTPS엔드포인트가 직접 인증서의 유효성을 검증하지 않고, 클라이언트의 자격증명을 제공하지 않음

## 컨트롤러

- 개요
  - 클러스터의 상태를 관찰한 다음, desired state로 필요한 경우에 생성 또는 변경을 요청하는 컨트롤루프
    - 현재 클러스터 상태를 의도한 상태에 가깝게 이동함

### 컨트롤러 패턴

- 개요
  - 컨트롤러는 적어도 하나 이상의 쿠버네티스 오브젝트(리소스 유형)를 추적하고, 의도한 상태에 가깝게 만듬
    - 클러스터 상태의 각 특정 측면을 관리할때 컨트롤러를 사용
- 특징
  - 컨트롤러가 API 서버로 메시지를 발송하여 제어
    - 클러스터 API서버와 상호작용하여 상태를 관리함(내장 컨트롤러의 경우)
    - e.g) 잡
      - 단일 팟 또는 여러 팟을 실행하고, 작업을 수행한 다음 중지하는 쿠버네티스 리소스
      - 동작 순서
        - 잡 컨트롤러가 새로운 작업 확인
        - API 서버에 팟을 생성하거나 삭제하도록 지시
        - API 서버가 주어진 요청을 실행
        - 새 잡의 의도한 상태는 해당 잡을 완료하는 것이므로, 잡 컨트롤러는 현재 상태를 의도한 상태에 가깝게 만들어줌
          - 팟을 생성해서 잡이 완료에 가까워지게 함
        - 잡 오브젝트의 설정을 업데이트(Finished)
  - 직접 제어
    - 클러스터 외부의 것을 변경할 경우에 사용
    - e.g) 클러스터 오토스케일러
      - API 서버에서 의도한 상태를 찾은 다음, 의부 시스템과 직접 통신하여 현재 상태를 보다 가깝게 만듬
      - 의도한 상태를 가져오기 위해서 약간의 변화를 주고, 현재 상태를 클러스터 API서버에 다시 보고
  - desired state와 status를 항상 비교하여 바로잡음
  - 동일한 종류의 오브젝트를 만들거나 업데이트하는 여러 컨트롤러가 존재 가능
    - e.g) 디플로이먼트와 잡
      - 잡 컨트롤러는 디플로이먼트가 생성한 팟을 삭제하지 않음(레이블로 구별)
  - 내장 컨트롤러 집합 존재(`kube-controller-manager`)
    - 복원력이 뛰어나, 어떤 내장 컨트롤러가 실패해도 다른 컨트롤 플레인의 일부가 작업을 이어서 수행

## 클라우드 컨트롤러 매니저

- 개요
  - 클라우드별 컨트롤 로직을 포함하는 쿠버네티스 컨트롤 플레인 컴포넌트이며, 클라우드 공급자 API에 연결하고, 해당 플랫폼과 상호작용하는 컴포넌트와만 상호작용을 함
- 특징
  - 기본 클라우드 인프라스트럭처와 쿠버네티스의 로직 분리
    - 서로 다른 속도로 기능을 릴리스 가능하게 해줌
  - 컨트롤 플레인에서 복제된 프로세스의 집합으로 실행됨(일반적으로, 팟의 컨테이너)
    - 단일 프로세스에 여러 컨트롤러를 구현

### 기능(포함된 컨트롤러들)

- 노드 컨트롤러
  - 개요
    - 클라우드 인프라에 새 서버가 생성될때, 노드 오브젝트를 업데이트하고 상태를 확인하는 역할
  - 기능
    - 1 클라우드 공급자 API를 통해 획득한 해당 서버의 고유 ID를 노드 오브젝트에 업데이트
    - 2 클라우드 관련 정보(e.g region, 리소스)를 사용해서 노드 오브젝트에 어노테이션과 레이블 작성
    - 3 노드의 호스트 이름과 네트워크 주소 가져옴
    - 4 노드의 상태 확인
      - 노드가 응답하지 않는 경우, 컨트롤러가 클라우드 API를 통해, 서버가 비활성화됨 / 삭제됨 / 종료됨 인지 확인
      - 노드가 클라우드에서 삭제된 경우, 컨트롤러는 사용자의 k8s클러스터에서 노드 오브젝트를 삭제
- 라우트 컨트롤러
  - 개요
    - 사용자의 쿠버네티스 클러스터의 다른 노드에 있는 각각의 컨테이너가 서로 통신할 수 있도록 클라우드에서 라우트를 적절히 구성해야 함
- 서비스 컨트롤러
  - 서비스는 관리형 로드밸런서, IP 주소, 네트워크 패킷 필터링 그리고 대상 상태 확인과 같은 클라우드 인프라스트럭처 컴포넌트와 통합 됨
  - 사용자의 클라우드 API와 상호작용하여, 서비스 리소스를 선언할 때 로드 밸런서와 기타 인프라스트럭처 컴포넌트 설정

### 인가

- 개요
  - 클라우드 컨트롤러 매니저가 작업을 수행하기 위해서 다양한 API 오브젝트에 필요한 접근 권한 세분화
- 노드 컨트롤러
  - 노드 오브젝트를 읽고, 수정이 필요
  - `v1/Node`
    - `Get`, `List`, `Create`, `Update`, `Patch`, `Watch`, `Delete`
- 라우트 컨트롤러
  - 노드 오브젝트의 생성을 수신하고 적절하게 라우트 구성. 노드 오브젝트에 대한 접근 권한이 필요
  - `v1/Node`
    - `Get`
- 서비스 컨트롤러
  - 서비스 오브젝트 생성, 업데이트 그리고 삭제 이벤트 수신 이후 해당 서비스에 대한 엔트포인트를 적절히 구성
  - `v1/Service`
    - `List`, `Get`, `Watch`, `Patch`, `Update`

### 그 외

- 클라우드 컨트롤러 매니저의 핵심 구현을 위해 이벤트 오브젝트 생성
- 안전한 동작을 보장을 위해 서비스 어카운트를 생성해야 함
- `v1/Event`
  - `Create`, `Patch`, `Update`
- `v1/ServiceAccount`
  - `Create`

## About cgroup v2

- 개요
  - 프로세스 그룹에 자원 할당을 제한하는 리눅스 커널의 기능
  - kubelet과 container runtime은 컨테이너들과 팟의 자원 할당 관리를 위해서 cgroup과의 인터페이스가 필요
    - cpu/memory requests / limits

## CRI(Container Runtime Interface)

- 개요
  - kubelet이 다양한 종류의 컨테이너 런타임을 클러스터 컴포넌트의 리컴파일 없이 사용 가능하게 하는 플러그인 인터페이스
  - kubelet이 container runtime을 사용해서 팟과 컨테이너들을 띄울 수 있게 해야하는데, 둘 사이를 이어주는 메인 프로토콜

## GC(Garbage Collection)

- 개요
  - k8s가 클러스터의 리소스를 정리하는 매커니즘을 설명하는 집합적인 용어
    - 정리 대상 리소스
      - Terminated pods
      - Completed pods
      - Objects without owner references
      - Unused containers and containter images
      - Dynamically provisioned PersistentVolumes with a StorageClass reclaim policy of Delete
      - Stale or expired CertificateSigningRequests(CSRs)
      - 다음과 같은 시나리오로 삭제된 노드들
        - cloud controller manager를 사용한 클러스터의 노드
        - cloud controller manager와 유사한 애드온을 사용한 온프레미스 노드
      - Node Lease objects

### Owners and dependents

- owner 참조
  - 개요
    - 오브젝트끼리 의존관계를 나타내는 매커니즘
      - 리소스 삭제시에도 고려되고, 대개 k8s가 알아서 처리해줌
