# 도메인 주도 설계 개요

- 의문
- 개요
- 책의 목차
- 제1부 동작하는 도메인 모델 만들기
  - 2장 의사소통과 언어 사용
  - 3장 모델과 구현의 연계
- 제2부 모델 주도 설계의 기본 요소
  - 4장 도메인의 격리

## 의문

- *DDD에서의 '도메인'의 정의는?*
- *목적조직에서는 어떻게 도메인을 나누고 설계해야 할 것인가?*
  - 애초에 DDD의 본질은 도메인 분리가 아니라, 소프트웨어의 유연성과 '커뮤니케이션' 아닌가?
- *모델은 어디까지 예외로직을 반영해야 하는가?*
  - *큰그림만 반영하면 되는가? -> 그런듯?*
- *도메인 레이어와 애플리케이션 레이어의 구체적인 차이점은 무엇일까?*

## 개요

- 마틴 파울러
  - 소프트웨어의 근본적 챌린지는 복잡함의 통제
    - 도메인 모델에 있음
  - 도메인 전문가와 기술자를 서로 공통언어로 이어줌
  - 개발과 설계는 계속해서 이어지는 것(처음부터 완벽한 설계는 없다)
- 복잡성은 기술적인 것이 아니라, 사용자의 활동이나 업무에 해당하는 도메인 자체
- DDD의 전제
  - 개발은 반복적인 주기를 토대로 진행되어야 한다
    - 변화와 불확실성에 대처하자
    - XP
      - 리팩토링을 토대로 설계를 개선하고, 리팩토링을 자주, 빠르게 수행한다고 가정
      - 설계와 개발 프로세스가 상호보완
  - 개발자와 도메인 전문가는 밀접한 관계에 있어야 한다
    - 지속적인 협업을 전제

DDD개요

![](./images/overview/ddd_overview1.jpg)

- 스토리 라인
  - 소프트웨어의 본질 = 도메인의 문제 해결
  - 소프트웨어 개발의 근본적 챌린지 = 복잡도 다루기
    - 복잡도의 근원은 domain
    - 결국 도메인의 복잡도를 잘 다뤄야 함
  - 도메인 복잡도를 잘 다루기 위해서는 도메인 전문가와 개발자의 의사소통이 중요함
    - 같은 언어 사용
    - 개발과 설계가 투명하게 대응되어야 함
  - 복잡도의 해결 방법은 지속적인 커뮤니케이션을 바탕으로 한, 소프트웨어의 성장
    - 반복적인 리팩토링이 필요(외부 환경 변화에 따라서)
    - 계속해서 도메인 모델을 분화시키고 발전시킴
    - 객체지향 base
  - 도메인 주도 팀이 중요함
    - 의사 소통의 중심을 도메인 모델로하기
    - *이 부분이 직접 목적조직으로 될 수 있는가?*
    - *DDD의 본질은 *

## 책의 목차

- 1부 "동작하는 도메인 모델 만들기"
  - DDD의 기본적인 목표 제시
  - DDD 용어 정의
  - 도메인 모델의 사용이 의사소통과 설계에 어떤 영향을 주는지 설명
- 2부 "모델 주도 설계의 기본 요소"
  - **객체지향** 도메인 모델링에서의 우수 실천법의 핵심을 요약
  - 모델과 구현(소프트웨어) 간의 간극을 메우기
    - 상호보완까지도
  - 표준화된 패턴 제시
- 3부 "더 심층적인 통찰력을 향한 리팩토링"
  - 가치를 제공하는 실용적인 모델을 만들기
  - **모델의 발견 과정 강조**
    - 원시적인 모델에 기반둔 초기 설계내용에서 반복해서 변형해나감
    - 팀원들은 통찰을 얻을때마다 모델은 풍부한 지식을 나타낼 수 있게 됨
      - 코드는 심층적인 모델을 반영하게끔 리팩토링 되어, 애플리케이션에 적용가능하게 됨
    - 지속적인 리팩토링
  - 모델의 발견 과정에서 선택을 돕는 모델링 원칙과 적절한 방향을 제시하는 기법을 살펴봄
- 4부 "전략적 설계"
  - 복잡한 시스템, 더 큰 조직, 외부 시스템 및 기존 시스템과의 상호작용에서 발생하는 상황 다룸
  - *context, distillation, 대규모 구조* 원칙 살펴보기
  - 전략적 설계
    - 더 큰 규모, 대형 시스템, 큰 애플리케이션의 팀단위 의사결정

## 제1부 동작하는 도메인 모델 만들기

모델: **소프트웨어로 현실 문제를 해결하기 위해서, 도메인을 추상화 한 것**

- 도메인
  - 정의
    - 사용자가 프로그램을 사용하는 대상 영역
- 모델
  - 정의
    - **소프트웨어로 현실 문제를 해결하기 위해서, 도메인을 추상화 한 것**
  - 행동 정의
    - 어떤 사실을 해석할 때, 당면한 문제를 해결하는 것과 관련된 측면을 추상화 함
      - 세부사항은 주의 기울이지 않음
    - **도메인 지식을 엄격하게 구성하고 선택적으로 추상화(디테일 제외) 한 것**
      - 다이어그램을 이용해 모델을 표현하고 전달 가능
    - 목적에 따라서 제약에 구애받지 않고 현실을 표현하는 영화 제작에 더 가까움
- 도메인과 모델
  - 도메인 지식이 위압적으로 많으므로, 그런 복잡성을 모델로 단순화하고 구조화
  - 모든것은 도메인 모델에 기반을 두어야 한다
    - 모든것
      - 용어, 설계, 구현, 아키텍처
- DDD에서 모델의 유용성
  - 1 모델과 핵심 설계는 서로 영향을 주며 구체화된다
  - 2 모델은 모든 팀 구성원이 사용하는 언어 중추
  - 3 모델은 지식의 정수만을 뽑아낸 것
- 소프트웨어의 본질
  - 도메인의 문제 해결
    - 개발자는 도메인 지식 증진에 몰두해야 함
    - 개발자는 도메인 모델링 기법을 연마해서 도메인 설계에 통달해야 함
- 효과적인 모델링의 요소
  - 1 모델과 구현의 연계
  - 2 모델을 기반으로 하는 언어 정제
    - 모든이가 모델을 기반으로 한 용어로 문장 구성 가능
  - 3 풍부한 지식이 담긴 모델 개발
  - 4 모델의 정제
    - 오직 본질적인 개념만 식별할 수 있도록
  - 5 브레인스토밍과 실험
    - 여러 모델링을 시도 & 평가
      - 말로 표현만해도 모델의 타당성 여부 판단 가능

### 2장 의사소통과 언어 사용

모델과 유비쿼터스언어의 관계 다이어그램

![](./images/overview/model_and_ubquitous_language1.jpg)

- Ubiquitous Language
  - 개요
  - 예시
    - RoutingService는 RouteSpecification을 만족하는 Itinerary를 찾는다
- 모델과 언어
  - 개요
    - **모델은 구현 / 설계 / 의사소통의 기반이 되어야 함**
      - 모델은 누구나(개발자 / 도메인 전문가)가 이해 가능해야 함
    - **언어는 의사소통 / 코드 / 다이어그램 등에서 사용되어야 함**
    - 모델과 언어는 각자의 변화에 싱크를 맞춰야 함
  - 참고
    - 모델은 다이어그램이 아니다
      - 다이어그램은 모델을 전달, 설명하기 위한 도구
- 문서
  - 코드, 말의 보완재
  - 문서는 유효한 상태를 유지하고, 최신 내용을 담고 있어야 함

### 3장 모델과 구현의 연계

한 도메인에서 모델, 설계, 프로그래밍은 계속해서 발전하고 대응되어야 함

- 모델과 코드
  - 개요
    - 코드는 모델로부터 대응되어야 함
      - **결국 코드는 모델의 한 표현**
      - 즉, 코드의 변경은 모델의 변경이므로 프로그래머는 모델러
    - 하나의 도메인에 **모델은 오직 하나** 여야 함, 그리고 그 모델만이 코드에 대응되어야 함
  - 모델과 코드의 간격이 끊기는 이유
    - 분석 모델
      - 오로지 도메인 이해를 위한 수단
      - 결국 설계/구현 단계에서 폐기되기 쉬움
    - 설계의 기반이 되는 개념(모델)이 부족한 소프트웨어는 기껏해야 해당 소프트웨어의 행위를 설명하지 모한 채 그저 유익한 일을 수행하는 매커니즘에 불과
    - 설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않으면, 그 모델은 그다지 가치가 없으며 소프트웨어의 정확함도 의심스러워진다
    - 모델과 설계 사이에 복잡한 대응관계가 되므로, 이해힘들고 유지보수가 불가능해짐. 통찰력이 서로에게 전달되지 않음
      - e.g) 호출예약
- 좋은 모델
  - 개요
    - 분석과 설계 관점에서 모두 효과적인(연결된) 모델(단일 모델)
      - 기술과는 분리됨
      - 분석과 설계 관점에서 어느쪽이든 효과적이지 못하면, 새로운 모델을 찾아야 함
    - 설계에 밀접하게 연관된 모델 **(모델이 먼저 정의되나, 그 모델은 설계와 관련있어야 함)**
      - 계속해서 리팩터링해야 함
      - 따라서, 설계시 도메인 모델을 있는 그대로 반영해야 함
    - 모델로부터 설계와 기본적인 책임 할당에 사용한 용어를 도출 가능해야 함
      - 코드 사용시 그러한 용어 사용
      - 코드의 변경이 곧 모델의 변경
  - 구현을 모델과 묶기위한 방법
    - 객체지향 프로그래밍과 같은 모델링 패러다임을 지원하는 소프트웨어 개발도구와 언어가 필요
  - 개발
    - 정의
      - 단일 모델을 <-> 설계, 코드를 단일한 활동으로 정제하는 반복적인 과정
        - 리팩터링 & 지식탐구의 반복
- 모델링 패러다임(MODEL-DRIVEN DESIGN)과 도구 지원
  - 정의
    - 모델과 구현을 매우 밀접하게 연결하는 패러다임
  - 방식
    - **객체지향 프로그래밍**
      - 모델링 패러다임에 근거하고, 모델의 구성요소에 대한 구현을 제공
      - 도메인의 활동적인 측면도 반영 가능
    - c.f) 절차지향 프로그래밍
      - 언어에 대응되는 모델링 패러다임 이 없어서 MODEL-DRIVEN DESIGN적용이 힘듬
      - 프로그램은 데이터를 기술적으로 조작할 뿐
    - **모델을 동작하게 만들어 애플리케이션의 문제를 해결**
  - 성공하기 위한 방식
    - 세부적인 설계 결정에 민감하게 영향을 받음
- 참고
  - 모델과 분석, 모델링, 설계, 프로그래밍을 지나치게 나누면 안된다

## 제2부 모델 주도 설계의 기본 요소

내비게이션 맵 예시

![](./images/overview/naviation_map1.jpg)

- 내비게이션 맵
  - 패턴과 패턴들이 서로 어떻게 관계를 맺는지 보여 줌
  - MODEL-DRIVEN DESIGN의 언어로 구성된 내비게이션 맵이 존재
- 표준 패턴
  - 특징
    - 설계에 체계가 생겨 팀 구성원이 각기 다른 구성원의 업무를 더욱 쉽게 이해할 수 있음
    - UBIQUITOUS LANGUAGE에도 표준 패턴을 사용하면, 모든 팀 구성원이 모델과 설계의 사결정에 관해 논의하는 데 활용 가능
  - 소프트웨어 시스템에서 도메인 설계를 격리하면, 모델과 설계의 관계가 훨씬 분명해짐
    - *무엇으로부터 격리? 정확한 의미가?*
- 도메인 모델의 개발
  - 모델의 개별 요소를 체계적으로 개발하자 How to
    - **시스템의 수많은 관심사에서 도메인의 설계 격리**
    - **일정한 구분법에 따라 모델의 요소를 정의**
    - **개별 요소에 대해 이미 널리 입증된 패턴을 따르기**
      - 표준 패턴()
  - c.f) DDD에서 모델을 표현하는 패턴(Entity, Value Object, Service)

### 4장 도메인의 격리

계층형 아키텍처

![](./images/overview/layered_architecture1.jpg)

**계층형(Layered) 아키텍처** 가 도메인을 격리하기 위한 수단 설계 기법 -> 내비게이션 맵 참고

- 배경
  - 도메인에 관련된 코드는 항상 도메인에만 격리되어 있어야 함(separation of concern)
    - 그렇지않으면, 코드  확인 및 추론이 매우 힘들어짐
- 계층형 아키텍처
  - 개요
    - 한 계층의 모든 요소는 오직 같은 계층에 존재하는 다른 요소나 계층상 아래에 위치한 요소에만 의존
      - 위로 거슬러 올라가는 의사소통은 반드시 간접적인 메커니즘을 거쳐야 함
  - 가치
    - 각 계층에서 프로그램의 특정 측면만을 전문적으로 다룸
      - 응집력 있는 설계
      - 설계의 이해가 쉬움
    - **본질은 도메인 계층을 나누는 것**
      - **도메인 객체는 도메인 모델을 표현하는 것에만 집중하도록**
        - 표현이나 저장, 애플리케이션 작업을 관리하는 등의 책임에서 자유로움
        - **모델이 진화를 자유롭게 계속할 수 있도록 하는것이 중요**
  - 일반적인 계층들
    - UI
      - 사용자에게 정보를 보여주고, 사용자 명령을 해석하는 책임
      - 사용자가 아닌, 다른 컴퓨터 시스템과의 관계일수도 있음
    - 응용 계층
      - 소프트웨어가 수행할 작업을 정의하고, 표현력있는 도메인 객체가 문제를 해결하게 함
      - 얇게 유지
      - 반영할 것
        - 작업 조정, 도메인 객체의 협력자에게 작업 위임
        - 업무 진행 상황 상태
      - 반영하지 않을 것
        - 업무 규칙, 지식
        - 업무 상황 상태
    - 도메인(또는 모델) 계층
      - 비즈니스 로직을 다루는 계층
        - 업무 개념, 업무 상황에 관한 정보, 업무 규칙을 표현하는 일
        - 업무 상태를 제어 및 사용
          - c.f) 업무 상태를 저장하는 것은 인프라스트럭쳐에게 위임
    - 인프라스트럭쳐 계층
      - 상위 계층을 지원하는 일반화된 기술적 기능 제공
        - 메시지 전송
        - 도메인 영속화
        - UI에 위젯 그리기
  - c.f) 도메인 계층과 인프라스트럭쳐 계층
    - 인프라스트럭쳐 계층이 도메인계층을 의존하는게 바람직
      - **인프라스트럭쳐가 바뀌어도 도메인은 바뀌면 안됨**
      - 도메인 레이어의 요소들(리포지토리, 서비스 등)은 interface로만 정의
