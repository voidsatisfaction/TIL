# Binary Search Tree: 이진 탐색 트리

- 각각의 노드는 키를 소유
- 왼쪽 서브트리는 그 서브트리에 속하지 않는 노드의 키보다 무조건 작다.
- 오른쪽 서브트리는 그 서브트리에 속하지 않는 노드의 키보다 무조건 크다.
- 보통 키는 유일하다(unique).

## API와 효율

- insert: `O(n)`
- search: `O(n)`
- deletion: `O(루트n)`

트리가 한쪽으로 편향되어있으면 최악의 경우 삽입과 검색에서 `O(n)`의 시간적 효율성을 보인다. 평균적으로는 4*log(n)이라고 한다.

그래서 균형 이진 탐색 트리(편향되지 않은 이진 탐색 트리)를 구현한다.

이진 탐색 트리는 퀵소트의 `partitioning(분할과정)`과 정확히 유사하다. 이는 여기서 말하는 분할과정은 three-way-partitioning이 아닌 일반적인 분할과정이다.

## 사용 가능한 특수 API

- min(): 가장 작은 키에 대응하는 값은?
- max()
- select(n): n번째 키에 대응하는 값은?
- ceiling(key Key) Key: key이후의 가장 작은 key는?
- floor(key Key) Key
- rank(key Key) int: key는 몇번째로 작은 key인가?
- size(key Key) int: key를 갖고 있는 노드가 루트인 서브트리의 노드 개수는?

## Iteration: 이터레이션

중위순회를 하면 모든 트리의 노드를 작은 키의 값에서 높은 키의 갚으로 순회할 수 있다. 중위순회를 하면서 모든 키를 새로운 배열에 넣어준다. 전부 다 순회하면 그 배열을 반환한다.

## 노드의 삭제

### 최소(최대) 키를 가지는 노드의 삭제

가장 왼쪽 노드까지 간다. 그 노드의 오른쪽 자식 노드가 존재하면 그 노드의 부모노드와 그 노드의 오른쪽 자식 노드를 연결 시켜준다.

### Hibbard 삭제

- 자식 노드가 존재하지 않는 경우
- 자식 노드가 하나만 존재하는 경우
- 자식 노드가 둘 다 존재하는 경우
  - 삭제되는 노드의 오른쪽 부분 트리에서 가장 작은 노드를 삭제되는 노드의 위치로 놓는다(immutable)
  - 단 계속해서 이를 진행하면, 트리의 편향성이 증가한다.
  - `O(루트n)`
