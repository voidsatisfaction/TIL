# Union-Find알고리즘

1부터 N까지의 임의의 노드가 있을 때, 임의의 두 노드를 간선으로 연결해 나간다. 「그럴 때 임의의 두 노드는 연결되어 있는가?」라는 쿼리에 효율적으로 대답하는 방법이 Union-Find알고리즘이다.

효율은 `n: 요소의 수, m: 쿼리의 수`일때
- 임의의 두 노드를 연결: `O(log(n))`
- 임의의 두 노드가 연결되어있는지 확인: `O(log(n))`

## 알고리즘 구현 방법

일차원 배열에 forest(트리의 집합)을 구현한다. 그리고 또 다른 배열에 각각의 트리의 크기(트리에 포함되는 노드의 수)를 일차원 배열에 기록한다.

1. 초기화로 모든 노드를 일차원 배열에 `노드번호==배열의 인덱스==배열의 인덱스에 해당하는 값`으로 둔다. 그리고 일차원 배열에 각각의 노드에 대한 트리 사이즈를 기록한다(전부 1). 참고로 배열의 인덱스에 대응하는 값은 `배열의 인덱스를 노드번호로 하는 노드를 포함하는 트리의 루트노드`를 의미한다.
2. 임의의 두 노드를 연결하라는 query가 올 경우, 사이즈가 더 작은 트리의 루트노드를 큰 트리의 루트노드로 바꾼다.
3. 임의의 두 노드가 연결되어있는가 확인하는 query가 올 경우, 각각의 노드에 대해서 root노드를 구하는 연산을 해서 두 값을 비교한다. 여기서, 임의의 두 노드를 배열의 인덱스로 하는 경우 그 값을 root노드로 바꿔준다.(flattening tree)
