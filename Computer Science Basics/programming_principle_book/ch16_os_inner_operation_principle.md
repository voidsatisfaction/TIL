# OS 속 들여다 보기 - OS의 내부 동작 원리

## 의문

## 16.1 프로세스 vs 메모리

- 프로세스와 메모리
  - 개요
    - 32비트 컴퓨터의 경우, 모든 프로그램은 4기가바이트의 메모리를 할당받아 사용
    - 각 프로세스의 메모리들이 0부터 시작해서 주소가 겹침에도, 침범되지 않음
      - 가상 메모리

## 16.2 프로그램이 실행되기까지

- 개요
  - 컴파일러
    - C소스 파일을 컴파일러가 해석, 타겟 CPU에 따라 적절한 인스트럭션을 생성
    - main파일에서 정의된 함수는 해당 함수의 기계어코드 생성
    - `printf`와 같은 함수의 경우, `#include<stdio.h>`에 기술된 stdio.h 파일도 함께 검사해서, `printf`함수가 정의된 것을 확인
      - 함수의 prototype만 정의되어 있음
      - 컴파일러가 prototype에 맞게 코드가 함수를 호출하는지 체크
    - 컴파일 마침
      - call 인스트럭션의 타겟 주소를 생성할 수 없음(아직 함수가 어디에 구현되어있는지 모르므로)
    - .obj 파일 생성
  - 링커
    - 컴파일러가 생성한 obj파일과 따로 지정된 라이브러리 파일들을 모두 검사하고 전부 합쳐서 최종적인 실행파일 생성(링킹)
      - 컴파일러가 obj파일에 체크해 둔 부분을 완성
        - 모든 목적파일과 지정된 라이브러리를 검사해서 체크한 함수가 존재하는지 확인하고 존재하면
        - 그 부분을 실행파일에 복사해오고
        - 그 복사된 주소를 호출하도록 체크한 부분을 채워 넣음
    - 대상
      - 함수의 호출, 전역 변수 참조
- 임베디드 환경 vs 멀티태스킹 OS 환경
  - 임베디드 환경
    - 직접 사용자가 점프할 절대주소나, 데이터가 위치한 메모리의 절대주소를 지정해서 사용
    - 어차피 실행되는 프로그램은 하나이므로 문제가 없음
  - 멀티태스킹 OS 환경
    - 문제
      - OS 자체도 버전업이 되어 사이즈가 바뀜
        - 절대주소를 사용하여 만들어진 응용 프로그램을 다시 컴파일 해줘야 함
    - 해결
      - 재배치 및 적재 시간 주소 바인딩
        - 개요
          - 프로그램을 메모리로 로드하는 시점에서 주소를 결정하는 것
          - OS의 프로그램 로더가 프로그램을 메모리로 로드하는 시점에 결정
          - 프로그램이 재배치가 가능한 형태로 컴파일되어 있어야 함
            - 0번지를 기준으로 한 상대적인 주소만 생성
            - 프로그램의 헤더에 재배치가 필요한 코드의 위치를 모두 기록
        - c.f) 컴파일 시간 주소 바인딩
          - 컴파일러가 컴파일 할 때, 코드에서 메모리상의 절대 주소를 정해주는 것
      - 실행시간 주소 바인딩
        - 개요
          - 주소의 결정이 최종적으로 CPU가 해당 인스트럭션을 실행할 시점에 결정나는 것
- 다중 분할 할당

## 16.3 멀티 프로그램을 위한 메모리 관리

- 문제
  - 단편화 문제
  - 스와핑 문제
- 구역성(Locality)
  - 종류
    - 공간구역성
      - 어떤 프로세스가 메모리의 한 곳을 일단 엑세스하기 시작하면 그 주변 데이터도 곧이어 사용될 확률이 높음
        - e.g) 인스트럭션은 순차적으로 실행
        - e.g) 배열은 전체 혹은 일부를 순회하면서 검사하는 경우가 많음
    - 시간구역성
      - 시간적인 관점에서 한 번 엑세스된 데이터는 곧이어 다시 엑세스될 확률이 높음
        - e.g) 루프를 돌 때, i와 같은 순회 변수를 사용하는 경우
        - e.g) 스택 세그먼트
  - 활용
    - 굳이 프로세스 전체 코드나 데이터를 다 메모리에 올릴 필요가 없음
    - 스와핑 자체도 공간구역성을 이용하여, 엑세스가 발생한 일정한 작은 영역에서만 스와핑을 함
    - 단편화 문제는, 구역성으로 인하여, 프로세스마다 구역의 크기를 다르게 할 필요가 없을것
      - 32비트 컴퓨터에서는 4KB 정도로 일정한 크기로 나누어서 사용

## 16.4 페이징

## 16.5 페이징을 활용한 가상 메모리

## 16.6 페이지 테이블을 위한 캐쉬 메모리 - TLBs

## 16.7 페이징을 통한 프로세스간 메모리 공유

## 16.8 CPU의 시간표 - 스케줄링

## 16.9 실시간 운영체제
