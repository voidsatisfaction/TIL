# OS 속 들여다 보기 - OS의 내부 동작 원리

## 의문

## 16.1 프로세스 vs 메모리

- 프로세스와 메모리
  - 개요
    - 32비트 컴퓨터의 경우, 모든 프로그램은 4기가바이트의 메모리를 할당받아 사용
    - 각 프로세스의 메모리들이 0부터 시작해서 주소가 겹침에도, 침범되지 않음
      - 가상 메모리

## 16.2 프로그램이 실행되기까지

- 개요
  - 컴파일러
    - C소스 파일을 컴파일러가 해석, 타겟 CPU에 따라 적절한 인스트럭션을 생성
    - main파일에서 정의된 함수는 해당 함수의 기계어코드 생성
    - `printf`와 같은 함수의 경우, `#include<stdio.h>`에 기술된 stdio.h 파일도 함께 검사해서, `printf`함수가 정의된 것을 확인
      - 함수의 prototype만 정의되어 있음
      - 컴파일러가 prototype에 맞게 코드가 함수를 호출하는지 체크
    - 컴파일 마침
      - call 인스트럭션의 타겟 주소를 생성할 수 없음(아직 함수가 어디에 구현되어있는지 모르므로)
    - .obj 파일 생성
  - 링커
    - 컴파일러가 생성한 obj파일과 따로 지정된 라이브러리 파일들을 모두 검사하고 전부 합쳐서 최종적인 실행파일 생성(링킹)
      - 컴파일러가 obj파일에 체크해 둔 부분을 완성
        - 모든 목적파일과 지정된 라이브러리를 검사해서 체크한 함수가 존재하는지 확인하고 존재하면
        - 그 부분을 실행파일에 복사해오고
        - 그 복사된 주소를 호출하도록 체크한 부분을 채워 넣음
    - 대상
      - 함수의 호출, 전역 변수 참조
- 임베디드 환경 vs 멀티태스킹 OS 환경
  - 임베디드 환경
    - 직접 사용자가 점프할 절대주소나, 데이터가 위치한 메모리의 절대주소를 지정해서 사용
    - 어차피 실행되는 프로그램은 하나이므로 문제가 없음
  - 멀티태스킹 OS 환경
    - 문제
      - OS 자체도 버전업이 되어 사이즈가 바뀜
        - 절대주소를 사용하여 만들어진 응용 프로그램을 다시 컴파일 해줘야 함
    - 해결
      - 재배치 및 적재 시간 주소 바인딩
        - 개요
          - 프로그램을 메모리로 로드하는 시점에서 주소를 결정하는 것
          - OS의 프로그램 로더가 프로그램을 메모리로 로드하는 시점에 결정
          - 프로그램이 재배치가 가능한 형태로 컴파일되어 있어야 함
            - 0번지를 기준으로 한 상대적인 주소만 생성
            - 프로그램의 헤더에 재배치가 필요한 코드의 위치를 모두 기록
        - c.f) 컴파일 시간 주소 바인딩
          - 컴파일러가 컴파일 할 때, 코드에서 메모리상의 절대 주소를 정해주는 것
      - 실행시간 주소 바인딩
        - 개요
          - 주소의 결정이 최종적으로 CPU가 해당 인스트럭션을 실행할 시점에 결정나는 것

## 16.3 멀티 프로그램을 위한 메모리 관리

- 다중 분할 할당
  - 개요
    - 프로그램을 실행할 때, 모든 데이터, 코드를 메모리에 적재
- 문제
  - 단편화 문제
    - 외부 단편화
      - 전체 메모리에서 프로그램 단위로 메모리가 듬성듬성 비어버리는 현상
    - 내부 단편화
      - 4KB 단위의 메모리 프레임에서 메모리가 듬성듬성 비어버리는 현상
  - 스와핑 문제

## 16.4 페이징

- 구역성(Locality)
  - 종류
    - 공간구역성
      - 어떤 프로세스가 메모리의 한 곳을 일단 엑세스하기 시작하면 그 주변 데이터도 곧이어 사용될 확률이 높음
        - e.g) 인스트럭션은 순차적으로 실행
        - e.g) 배열은 전체 혹은 일부를 순회하면서 검사하는 경우가 많음
    - 시간구역성
      - 시간적인 관점에서 한 번 엑세스된 데이터는 곧이어 다시 엑세스될 확률이 높음
        - e.g) 루프를 돌 때, i와 같은 순회 변수를 사용하는 경우
        - e.g) 스택 세그먼트
  - 활용
    - 공간구역성을 생각하면, 굳이 프로세스 전체 코드나 데이터를 다 메모리에 올릴 필요가 없음
    - 스와핑 자체도 공간구역성을 이용하여, 엑세스가 발생한 일정한 작은 영역에서만 스와핑을 함
    - 단편화 문제는, 공간구역성으로 인하여, 프로세스마다 구역의 크기를 다르게 할 필요가 없을것
      - 32비트 컴퓨터에서는 4KB 정도로 일정한 크기로 나누어서 사용
- 페이징
  - 개요
    - 물리적 메모리를 4킬로바이트 단위로 차례대로 쪼개서 번호를 매김
      - 프레임
    - 프로세스의 코드와 데이터 전체를 4킬로바이트 단위로 쪼갬
      - 페이지
  - Demand 페이징
    - 개요
      - CPU가 메모리 접근을 요구할 때마다 페이지의 부재 여부를 확인해서 없으면 로드
    - 시나리오
      - 프로그램을 실행
      - 프로세스만 생성(메모리에 코드, 데이터 올려두지 않음)
      - CPU가 PC레지스터가 가리키는 메모리 주소에 코드 혹은 데이터가 있는지 확인
      - 코드 혹은 데이터가 없으므로 페이지 폴트 인터럽트(에러) 발생
      - ISR 동작
        - 필요한 페이지를 메모리 프레임 중 한 곳으로 로드
      - 다시 CPU는 정상적인 인스트럭션 수행
        - 웬만하면 페이지 폴트를 일으키지 않을것(공간구역성)
    - 장점
      - 다중 분할 방식 때보다 훨씬 많은 프로세스가 동시에 수행 가능
      - 외부 단편화가 발생하지 않음
      - 서로 다른 프로세스가 같은 주소의 물리 메모리를 엑세스 할 수 있음

## 16.5 페이징을 활용한 가상 메모리

페이지 테이블 도식

![](./images/ch16/page_table1.png)

- 가상 메모리
  - 개요
    - CPU가 요구하는 논리적 주소와 메모리의 물리적 주소를 매핑하는 기술
    - 페이지 테이블을 사용
      - 몇번째 페이지 + 몇번째 바이트 -> 몇번째 프레임 + 몇번째 바이트
      - 몇번째 바이트는 페이지나 프레임이나 같으므로, 몇번째 페이지가 몇번째 프레임과 매핑되는지만 확인하면 됨
  - 프레임 정보 표현
    - 프레임 안에서 몇번째 바이트인지 나타내기
      - 프레임의 크기 4KB = 2^12바이트
      - 12개의 비트만 있으면 프레임 내부의 몇번째 바이트인지 파악 가능
    - 몇 번째 프레임인지 나타내기
      - 32비트 컴퓨터이면 나머지 20비트로 표현
      - 2^20개의 프레임 = 1048576개의 프레임
  - 페이지 정보 표현
    - 페이지 안에서 몇번째 바이트인지 나타내기
      - 페이지 크기 4KB = 2^12바이트
      - 12개의 비트만 있으면 페이지 내부의 몇번째 바이트인지 파악 가능
    - 몇 번째 페이지인지 나타내기
      - 프레임과 같음
    - 예시
      - `0000 0000 0000 0001 0000 0000 0011`
        - `0000 0000 0000 0001`는 페이지 번호 = 1
        - `0000 0000 0011`는 오프셋 = 4(0부터 인덱싱되므로)
  - 페이지 - 프레임 매핑 페이지 테이블의 문제
    - 사이즈 문제
      - 32비트 CPU에서 필요한 페이지 테이블의 크기가 너무 큼
      - 페이지 테이블은 2^20의 항목을 지녀야 함
      - 각 항목은 또 2^20까지의 수를 표현할 수 있어야 함
        - 항목별 메모리 크기는 3바이트(2^24 비트)
      - 따라서 한 프로세스당 6메가바이트의 페이지 테이블이 존재해야 함
    - 해결책
      - 페이지의 사이즈를 크게 잡기
        - 예시
          - 4KB -> 4MB
        - 문제
          - 내부 단편화 문제가 심각해짐
      - *이중 페이지 테이블(다시 공부해보자)*
        - 페이지 테이블 크기 자체가 크므로, 그것 자체를 메모리 페이징을 했던것 처럼 페이징을 함
          - 페이지 번호로 사용하던 구간을 다시 쪼개서, 외부 페이지 테이블의 인덱스와 외부 페이지 테이블의 오프셋으로 나눔
            - 페이지 테이블을 위한 공간을 1MB정도로 확보함
            - 외부 페이지 테이블의 구획을 1KB로 쪼갬
          - 모든 페이지 테이블을 메모리에 보관하는 대신, 구획으로 쪼개진 페이지 테이블 중, 현재 엑세스 중인 구획만 페이지 테이블 메모리에 매핑하고, 이를 위한 외부 페이지 테이블만 메모리 상에 유지

## 16.6 페이지 테이블을 위한 캐쉬 메모리 - TLBs

- 페이징의 단점
  - 페이지 테이블로 인한 메모리 엑세스 횟수의 증가
    - 속도의 병목
    - CPU연산 중에서, 메모리 접근은 매우 느린편에 속함
    - 페이징 도입하면, 메모리에 연속해서 두번 접근해야 함(페이지 테이블 엑세스, 메모리 에서 데이터 가져오는 엑세스)
      - 2배의 시간 지연 발생
- 문제 해결
  - TLBs(Translation Look-aside Buffers)
    - 개요
      - CPU 내부의 일종의 하드웨어로서, 페이지 테이블의 캐쉬 메모리
        - 구역성 이론에 기반
      - 메모리 엑세스시, 페이지 테이블 검색하기 전에 먼저 TLBs를 살펴봄
    - 구조
      - 논리 주소의 페이지 번호 <-> 물리 메모리에서의 프레임 번호
    - 동작
      - 논리 주소가 생성되면, 이 주소의 페이지 번호 비트들은 TLBs의 첫번째 항(페이지 번호 항)과 동시에 비교
        - 동시에 비교하기 때문에 하드웨어가 복잡해지고 비싸짐
      - 일치하는 행이 발견되면, 그 행의 프레임 번호가 활용됨
      - 일치하는 행이 발견되지 않으면, 페이지 테이블로가서 프레임 번호를 읽어옴 & 페이지 번호와 프레임 번호를 TLBs에 기록
        - 구역성에 의해 한동안 TLBs만으로 물리 주소 생성 가능
        - TLBs는 2000행 내외이나, 효과가 엄청남

## 16.7 페이징을 통한 프로세스간 메모리 공유

- 배경
  - 인터넷 익스플로러에서 팝업 창이 뜬다던지, 새로운 창을 띄우는 경우가 존재
    - 창이 뜰 때마다 별도의 프로세스 생성
  - 인터넷 익스플로러의 코드 부분을 메모리에 한 번만 로드하고, 데이터만 각 프로세스별로 로드
    - 페이지 테이블을 잘 조작
      - *구체적으로 어떻게 페이지 테이블을 조작하는 것일까?*
    - 윈도우즈에서는 DLL라는 이름으로 이러한 기술을 활용
- DLL
  - 개요
    - 윈도우즈는 4GB 프로세스 공간 중 상위 2GB는 항상 DLL을 위한 공간으로 활용
    - WIN32 API와 같은 시스템 함수들은 전부 DLL형태로 구성
      - 메모리상의 코드를 공유해서 메모리 절약

## 16.8 CPU의 시간표 - 스케줄링

- 스케줄링
  - 개요
    - CPU 자원의 수행권을 분배해주는 것
- 문맥 전환
  - 개요
    - 실행되던 프로세스가 멈추고 다른 프로세스를 수행하는 방법
  - 방법
    - CPU의 레지스터 값을 프로세스 마다 할당되는 PCB(Process Control Block)에 저장
      - 사실, 윈도우즈는 스레드의 개념을 사용해 TCB에 레지스터를 백업
      - PCB에 저장되는 것들
        - 레지스터
        - 페이지 테이블
        - fds
        - 프로세스 이름
    - 비선점형 OS
      - OS의 API(Sleep, ReadFile 과같은 함수)함수에서 문맥 전환 함수를 호출함
        - **OS는 능동적으로 동작하지 않는다**
          - OS는 일종의 라이브러리 형태로 OS함수를 제공하고, 작성된 프로그램에 의해 시스템 운영을 해나가는 보조적인 역할
          - e.g) 비선점형 OS 문맥전환, 힙 메모리 할당(malloc)
      - 그러한 함수가 호출되지 않고 계속 작업할 경우, 나머지 프로세스는 대기
      - e.g) Windows95
    - 선점형 OS
      - 외부 타이머 레지스터의 타이머 인터럽트 + 비선점 OS의 방식처럼 API함수를 이용한 문맥 전화
        - 인터럽트가 발생하면 ISR에서 문맥 전환을 하는 코드를 실행
      - e.g) Windows98
- c.f) 최대 절전 모드
  - 개요
    - 모든 메모리의 내용과 CPU 레지스터 값 등을 전부 하드디스크에 백업 & 전원 끄기
    - 다시 전원을 키면 OS가 부팅중에 백업 데이터를 메모리와 CPU 레지스터를 옮김
      - 전원끄기 이전 상태로 돌아감

## 16.9 실시간 운영체제
