# OS 속 들여다 보기 - OS의 내부 동작 원리

- 프로세스 vs 메모리
- 프로그램이 실행되기까지
- 멀티 프로그램을 위한 메모리 관리
- 페이징
- 페이징을 활용한 가상 메모리
- 페이지 테이블을 위한 캐쉬 메모리 - TLBs
- 페이징을 통한 프로세스간 메모리 공유
- CPU의 시간표 - 스케쥴링
- 실시간 운영체제

## 의문

- *POSIX는 커널 level의 인터페이스인가? 아니면 shell level의 인터페이스인가?*
- *소켓이란 무엇인가?*
- *프로세스의 힙 segment는 stack segment와 같이 정해진 크기가 존재하는가?*

## 개요

- 단편화
  - 멀티 태스킹을 지원하는 OS에서 메모리상에 동시에 여러 프로세스가 실행
  - 이 때, 이러한 프로세스 이미지들이 메모리에 로드되어 실행하다가 프로세스의 종료, 스와핑에 의해 메모리에서 다시 내려가기도 하는데, 이러한 과정이 반복되면 메모리가 연속적으로 사용되지 않고 중간중간 사용되지 않는 자투리 구간이 생김
  - 이런 구간이 또 다른 프로세스 이미지를 수용하기에 충분히 크지 못하면 사용되지 못하고 낭비됨
  - 이것을 탄편화라 함
- 페이징
  - 단편화를 해결하기 위한 방법

## 1. 프로세스 vs 메모리

### 멀티 프로그래밍 OS 에서의 프로세스

- 다른 프로세스와의 공존에 신경을 써야 함
  - 하드웨어 자원
    - CPU, 메모리, 마우스, 키보드, I/O장치
- CPU 공존
  - **스케쥴링으로 해결**
- 메모리 공존
  - 한 프로그램 마다 자신이 필요한 메모리의 주소를 분명히 해야함
  - 예시
    - 파워포인트 0~1000 번지
    - 워드 1001~2000 번지
  - 과거의 문제
    - 프로그램을 개발하는 시점에는 그 프로그램이 돌아갈 환경에 대해서 전혀 가정할 수 없음
      - 컴퓨터의 메모리 크기를 알 수 없음
    - 과거에는 하드웨어 메모리가 매우 적었음
      - 도스 시절 640kB 제약
      - 게임
        - 모든 이미지를 다 로드하는 대신, 매 스테이지마다 이미지를 로드
      - 워드 프로세서
        - 눈에 보이는 페이지의 데이터만 메모리에 유지하면서 페이지 스크롤을 할 떄마다 갱신
  - 과거의 해결
    - 개발자가 모든 것을 처리(오버레이)
      - 코드가 메모리의 몇 번지에 로드되어야 하는지
      - 로드하기 위해 기존의 어떤 코드나 데이터를 메모리에서 제거해야 하는지
  - 현재의 해결
    - OS가 똑똑해져서 개발자가 메모리를 어떻게 나눠야 하는지 등에 대해서 신경쓰지 않아도 됨
      - 오히려 직접 메모리를 지정해서 사용하는 것이 위험함
      - 항상 OS가 제공하는 API를 사용해서 메모리를 할당받거나, 프로그램상에서 변수를 선언해서 사용해야 함
      - 이렇게 하면 다른 프로그램에 의해 침범되는 걱정이 없음
    - 모든 프로그램은 모두가 각각 자신만이 사용할 수 있는 4GB 메모리를 할당 받아 사용(32비트 컴퓨터인 경우)
      - 10개의 프로그램이 동시에 동작하면, 총 40기가바이트의 메모리가 배정되어 있는 것
      - 심지어 각 메모리들이 모두 0번지부터 시작해 주소가 겹치는데, 서로 침범하지 않음
    - **가상 메모리(Virtual Memory)**
      - 각 프로세스 마다 받아 사용하는 고유의 메모리
      - 가상 메모리가 4기가바이트로 제한되는 이유
        - CPU가 32비트이기 떄문
          - 모든 레지스터가 32비트
          - PC레지스터도 32비트
            - 메모리 주소가 4기가바이트로 제한
        - CPU가 64비트라면
          - `2^64`비트의 크기를 갖는 가상 메모리를 한 프로그램이 사용 가능

## 2. 프로그램이 실행되기까지

- OS의 메모리 관리 기능을 이해하기 위해서는 프로그램이 어떤 과정을 거쳐 실행이 되는지 알아야 함

```c
#include <stdio.h>

int Add(int a, int b)
{
  return a + b;
}

int main()
{
  int Sum = Add(3,5);
  printf("3 + 5 = %d\n", Sum);
  return 0;
}
```

- (윈도우즈 에서는) 위의 코드를 타이핑하고 빌드 버튼을 누르면 `~.exe`와 같은 실행 파일이 생성될 것
  - 컴파일과정 뿐 아니라 **링킹(linking)** 과정도 존재

![](./images/os_inner_principle.png)

- 실행 파일이 생성되기 까지
  - 컴파일러
    - C 소스파일을 컴파일러가 해석
    - CPU에 따라 적절한 인스트럭션 생성
      - `call`, `mov`
      - 컴파일러가 위에서 부터 차례대로 소스를 보면서 가장 먼저 나온 `Add` 함수에 대해 코드를 생성
      - `main`함수의 코드 생성
        - `Add`함수가 존재하는지 살펴봄
        - `Add`함수 호출하는 코드 생성
        - `printf`를 호출하는 루틴을 만남
          - `printf`검사
            - `#include<stdio.h>`에 기술된 `stdio.h`파일도 함꼐 검사
            - 함수의 prototype만 구성되어있고 실제 `printf`를 구현하는 내용은 존재하지 않음
            - 인자등이 정의된 형식에 맞게 호출하고 있는지만 확인
            - 함수를 호출하는 `call` 인스트럭션의 타겟 주소 생성 불가(printf가 있었다는 체크만 해둠)
    - `.obj` 파일의 생성
      - 아직 완전한 실행코드가 아님
  - 링커
    - 컴파일러가 생성한 목적 파일과 따로 지정된 라이브러리 파일들을 모두 검사해서 취합하는 역할
    - 각종 라이브러리 검사후 합쳐서 실행 파일 생성(링킹)
      - 위의 경우 `yyy.lib`라이브러리 파일이 지정되어 있음
      - 링커는 `xxx.obj` 파일과 `yyy.lib`파일을 모두 검사해 합침
        - *결국 그럼, 데이터 segment에 라이브러리의 코드(yyy.lib)도 같이 올라가게 되는것인가?*
      - 최종적으로 `zzz.exe` 실행 파일을 생성
    - 함수의 호출 뿐 아니라 전역 변수를 참조할 때도 마찬가지
      - `extern int VAR` 라고 선언 되어있으면 `VAR` 변수의 공간을 실제로 생성하는 대신, `VAR`를 참조하는 곳마다 체크해둠
    - 링킹 작업 상세
      - 도스 파일
        - `com`
          - 절대주소를 사용한 링킹(컴파일 주소 바인딩)
          - 사용자가 점프할 절대주소나 데이터(변수)가 위치한 메모리의 절대주소 지정해서 사용가능
            - 세그먼테이션 개념을 사용해서 해당 세그먼트 안에서 절대주소처럼 사용할 수 있었음
          - 임베디드 시스템에서는 이와같이 절대 주소를 사용한 프로그램이 바람직
          - 문제
            - OS가 있는 환경에서는 절대 주소를 사용하는 것이 힘듬
              - OS도 하나의 프로그램 코드이므로, 버전업이나 이 코드의 데이터 크기가 동적으로 변하는 경우에 절대주소 체계를 사용하면 재컴파일이 필요함
            - 멀티 태스킹 OS인 경우에는 더 심각해짐
              - 각 프로그램이 언제 몇개가 로드 될지 모르므로 시작 주소는 무조건 가변적임
        - `exe`
      - **재배치(relocation)및 적재 시간 주소 바인딩(Load Time Address Binding)**
        - 주소 바인딩
          - `call` 인스트럭션을 통해 다른 함수를 호출하려 하는데, 이때 호출될 함수의 주소를 언제 결정하는가 하는 문제가 있음
          - 컴파일 주소 바인딩
            - 컴파일(+링킹)하는 과정에서 주소가 결정됨
            - `call printf` -> `call 750`
          - 적재 시간(Load Time) 주소 바인딩
            - 프로그램을 메모리로 로드 하는 시점에서 주소를 결정하는 것
            - 컴파일러나 링커는 메모리 주소를 필요로 하는 인스트럭션에 표시만 해두고, 로드하는 시점에서 주소를 확정 짓도록 함
            - **OS의 프로그램 로더가 이를 결정**
            - **프로그램은 재배치(Relocaiton)이 가능한 형태로 컴파일 되어있어야 함**
              - 메모리 주소가 필요한 인스트럭션에서 0번지를 기준으로 한 상대적인 주소만 생성하고, 실행 파일의 헤더 등에 재배치가 필요한 인스트럭션이 어디에 위치하는 지를 표시해 둠
              - 로더가 프로그램을 실행하면서 로드된 시작 지점의 주소를 이들 상대주소에 더해 최종적인 타겟 주소 완성
          - 실행 시간(Execution Time) 주소 바인딩
            - 주소 결정이 최종적으로 CPU가 해당 인스트럭션을 막 실행시키는 시점에서 결정

## 3. 멀티 프로그램을 위한 메모리 관리

## 4. 페이징

## 5. 페이징을 활용한 가상 메모리

## 6. 페이지 테이블을 위한 캐쉬 메모리 - TLBs

## 7. 페이징을 통한 프로세스간 메모리 공유

## 8. CPU의 시간표 - 스케쥴링

## 9. 실시간 운영체제
