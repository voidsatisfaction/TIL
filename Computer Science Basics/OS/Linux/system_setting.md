# 시스템 설정: 로깅, 시스템 시간, 일괄 작업과 사용자

- 의문
- 개요
- `/etc`의 구조
- 시스템 로깅
  - 시스템 로거
  - 설정 파일
- 사용자 관리 파일
  - `/etc/passwd`파일
  - Groups 활용
  - 참고) macOS의 경우

## 의문

## 개요

- 시스템 라이브러리가 서버와 사용자 정보를 구하기 위해 접근하는 설정 파일들
- 시스템이 부팅할 때 실행되는 서버 프로그램들(데몬)
- 서버 프로그램과 설정 파일들을 변경하는 데 사용될 수 있는 설정 유틸리티
- 관리 유틸리티

### c.f) 데몬

- 사전적 정의
  - **사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램(OS level)**
  - 유닉스에서 부모 프로세스가 PID 1(init) 이고, 제어하는 터미널이 없을 때, 그 프로세스를 데몬이라 부름
    - 자식 프로세스를 fork 하여 생성 -> 자식을 분기한 자신을 죽임 -> init이 고아가 된 자식 프로세스를 자기 밑으로 데려감
  - MS 계열에서는 서비스라고 부름
  - e.g
    - `syslogd`
- 특징
  - *데몬은 mother system(or thread, process)에 기생하는 형태로 존재하는 system으로, mother system이 exit한 경우에, 해당 데몬 역시 exit하게 되는 특성을 갖는다.*
    - 예시
      - *OS와 함께 실행되는 데몬 프로그램은 OS가 꺼질 때, 같이 꺼짐*
        - `OS == init`?
          - `init`은 보통 OS의 booting에서 가장 마지막에 실행되고, 프로세스 중에서는 가장 먼저 실행이되고, 부팅시 자동으로 실행해놓은 프로그램들을 실행시켜 줌
          - `systemd`는 프로세스 생성과정에서 병렬화 기능을 제공해서 `init`프로세스 보다 부팅이 빠르게 가능하도록 함
      - python3에서 daemon옵션을 주어서 새 thread를 spawn할 수 있음. daemon옵션이 True인 경우, 부모 스레드가 죽으면 해당 스레드도 죽음

## `/etc`의 구조

- 개요
  - (`/etc`)대부분의 시스템 설정 파일을 찾을 수 있는 곳
    - 특히, **개인의 사정에 맞게 수정이 가능한 설정** 들을 보냄
    - **변경이 불가능한 보편적인 적용에 관한 사항은 다른 패스에서 발견될 수 있음**
      - `/usr/lib/systemd` 등
- 문제점
  - 특정 설정 파일들을 찾기가 어려움
  - 설정된 시스템을 유지해 나가기가 어려움
- 해결
  - `/etc`가 아닌 그 서브디렉터리에 설정 파일을 보관

## 시스템 로깅

- 시스템 프로그램들의 진단 결과를 `syslog` 서비스에 기록
- `syslogd` 데몬은 메시지를 기다렸다가 받은 메시지의 종류에 따라서, 파일, 스크린, 사용자 또는 이들 중여러 곳으로 그 출력을 redirect

### 시스템 로거

- System Logger
  - 개요
    - 뭔가 문제가 생겼는데 어디에서 비롯된 문제인지 알 수 없는 경우 시스템 로그 파일을 확인
    - 대부분의 리눅스 배포판은 `rsyslogd`라고 하는 `syslogd`의 새로운 버전을 실행
  - 대부분 시스템 로그의 위치
    - `/var/log`

### 설정 파일

- `/etc/rsyslog.conf` or `/etc/syslog.conf`
  - 구성
    - selector, action 으로 이루어짐
      - 어디에서 얻은 기록을 어디로 보낼까?
    - selector
      - 기록되는 정보의 유형
    - action
      - 로그를 보낼 곳
    - 예시
      - `kern.*  /dev/console`
      - `*.info;authpriv.none  /var/log/messages`
        - `/var/log/messages`에 `*.info`에서 생기는 로그 저장
  - facility, prioirty
    - facility
      - `kern`, `authpriv` 등
    - prioirty
      - `none`, `debug`, `info`, `notice`, `warning`, `err`, `crit`, `alert`, `emerg`
      - 정해진 우선순위보다 상위의 우선순위에 해당하는 메시지를 해당 라인의 목적지로 보냄

## 사용자 관리 파일

- 유닉스 시스템은 다수의 독립적 사용자를 허용
  - 커널 레벨 에서는 사용자는 단순히 숫자(사용자 ID)일 뿐
  - 대신 관리할때는 숫자보다 이름이 편리하므로, 사용자명으로 작업
  - 사용자명은 사용자 공간에만 존재
  - 프로그램에서 사용자를 언급할 경우, 사용자명을 사용자 ID로 매핑이 가능해야 함

### `/etc/passwd`파일

*왜 저 파일에 프로그램 이름 같은 사용자명이 많지?*

- 개요
  - 사용자명을 사용자 ID와 매핑함
- 필드 설명(7개)
  - **사용자명(로그인명)**
  - **사용자의 암호화된 비밀번호**
    - linux 시스템에서는 `shadow`파일에 저장, 절대 평문 아님
    - `x`는 암호화된 비밀번호가 shadow 파일에 저장되었다는 것을 의미
    - `*`사용자가 로그인 할 수 없음
  - **사용자 ID(UID)**
  - **그룹 ID(GID)**
    - `/etc/group` 파일에서 번호가 붙은 항목들 중 하나
    - 파일 접근 권한을 결정하고 그 외에 다른 역할은 거의 없음
  - **사용자의 실제 이름**
  - **사용자의 홈 디렉터리**
  - **사용자의 셸**
    - 터미널 세션을 사용할 때 실행하는 프로그램
- 특수 사용자
  - `root`
    - UID, GID = 0
  - `daemon` 같은 친구들
    - 로그인 권한이 없음
  - `nobody`
    - 권한이 없는 사용자
    - 프로세스가 nobody로 실행이 될 수는 있으나, 시스템에 아무것도 기록 할 수 없음
  - `pseudo-user`
    - 로그인할 수 없는 사용자
    - 로그인 할 수는 없으나, 그 사용자 ID로 프로세스를 시작할 수 있음
    - `nobody`는 보안상의 이유로 생성되는 사용자임
- 사용자와 비밀번호 조작
  - `passwd` 명령
    - `-f` 사용자의 실제 이름 변경
    - `-s` 사용자 셸을 `/etc/shells`에 열거된 것들 중 하나로 변경
    - 오직 루트 사용자만 가능
- 커맨드로 조작
  - `adduser`
  - `userdel`
  - `passwd`

### Groups 활용

- 개요
  - 특정 사용자들하고만 파일을 공유하고, 그 외 모든 사람들의 접근은 허용하지 않는 방법 제공
  - 많은 사람들이 하나의 머신을 공유했던 시절에 매우 중요했음
- 파일 위치
  - `/etc/group`
    - 그룹 ID정의
- 필드 설명
  - **그룹명**
  - **그룹 비밀번호**
    - 거의 사용할 일이 없을 것
  - **그룹 ID(숫자)**
    - 파일 안에서 고유하게 정해져야 함
    - `/etc/passwd`파일의 사용자 그룹 필드에 들어감
  - **해당 그룹에 속한 사용자들**
    - 여기에 열거된 사용자들 뿐 아니라, `passwd`파일 항목에서 그룹 ID가 일치하는 사용자들도 그 그룹에 속함
- 참고
  - 일부의 리눅스 배포판은 새로운 사용자가 추가될 때, 같은 이름의 새로운 그룹을 생성함

### 참고) macOS의 경우

- user
  - 일반적으로 `staff` 그룹에 속함
- admin
  - `staff`, `admin` 그룹
- 참고) wheel 그룹
  - root만 속한 그룹
  - wheel group에 관련된 행위를 하기 위해서는 `sudo` 권한이 필요함
