# Ch2 운영체제 구조

- 의문
- 목표
- 2.1 운영체제 서비스
- 2.2 사용자와 운영체제 인터페이스
- 2.3 시스템 콜
- 2.4 시스템 서비스
- 2.5 링커와 로더
- 2.6 응용 프로그램이 운영체제마다 다른 이유
- 2.7 운영체제 설계 및 구현
- 2.8 운영체제 구조
- 2.9 운영체제 빌딩과 부팅
- 2.10 운영체제 디버깅

## 의문

## 목표

- 운영체제에서 제공하는 서비스 식별
  - 서비스를 제공하기 위해서 시스템 콜을 사용하는 방법
- 운영체제 설계
  - 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략
- 운영체제 부팅 프로세스
- 운영체제 성능을 모니터링하기 위한 도구
- Linux 커널과 상호작용하기 위한 커널 모듈을 설계하고 구현

## 2.1 운영체제 서비스

- OS가 제공하는 사용자 친화적 서비스
  - UI
    - GUI
    - CLI
  - 프로그램 수행
  - 입출력 연산
  - 파일 시스템 조작
  - 통신
    - IPC
    - Network
  - 오류 탐지
- OS가 제공하는 시스템 자체의 효율적인 동작 보장 서비스
  - 자원 할당
    - CPU 스케줄링 등
  - logging
  - 보호와 보안

## 2.2 사용자와 운영체제 인터페이스

- CLI
  - 명령어 인터프리터가 실행할 명령어의 코드 자체를 갖고 있기 vs 실행할 명령어에 대응하는 프로그램의 위치만 알고 있기
    - Unix는 후자
    - 새로 명령어를 추가하기 용이
- GUI
  - 데스크톱
  - 터치스크린

## 2.3 시스템 콜

- 개요
  - 운영체제에 의해 사용가능하게 된 서비스에 대한 인터페이스 제공
  - 일반적으로 C, C++ 언어로 작성된 함수 형태로 제공
- 특징
  - 운영체제에 매개변수를 전달하기 위한 방법
    - 1 매개변수를 레지스터 내에 전달
    - 2 레지스터보다 매개변수가 많으면, 매개변수는 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달
    - 3 블록이나 스택을 사용
      - *블록은 뭐지?*
  - application 개발자는 시스템콜을 직접 사용하는것 보다, API에 따라 사용
    - e.g)
      - Windows API
      - POSIX API
      - Java API(JVM)
    - API를 사용하는 이유(시스템 콜을 직접 사용하지 않고)
      - 프로그램의 호환성
  - c.f) RTE(RunTime Environment)
    - 개요
      - 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는 데 필요한 전체 소프트웨어 제품군과 라이브러리 또는 로더와 같은 다른 소프트웨어를 함께 가리킴
      - 자체적으로 시스템 콜 인터페이스 제공
- 시스템 콜의 유형
  - 프로세스 제어
    - `fork()`
      - 새로 프로세스 생성
    - `exec()`
      - 프로그램을 메모리에 적재 후 실행
  - 파일 조작
    - `create()`, `delete()`, `open()`, `close()`
    - `read()`, `write()`
    - `get_file_attribute()`, `set_file_attribute()`
    - `move()`, `copy()`
    - 일부 시스템은 동일한 작업을 수행하는 시스템 프로그램을 제공하기도 함
  - 장치 조작
    - 주기억 장치, 디스크 드라이브, 파일에의 접근 등
      - *이것과 파일 조작의 차이는?*
    - 장치의 종류
      - 물리적 장치
        - 디스크 드라이브
      - 추상적 장치
        - 파일
    - 장치 사용 요청
      - `request(), release()`
      - `read(), write()`
  - 정보 유지 보수
    - 사용자 프로그램과 운영체제 간의 정보 전달
    - `time(), date()` 그 외에도 자유 메모리, 자유 디스크 공간과 같은 정보 알려줌
    - `dump()`
      - 디버깅에 좋음
    - `get_process_attribute(), set_process_attribute()`
  - 통신
    - 메시지 전달 모델
      - 통신하는 두 프로세스가 정보를 교환하기 위하여 서로 메시지를 주고받음
      - 연결이 열려 있어야 함
        - 상대 통신자에 대한 정보를 알아야 함
        - 호스트 이름과 프로세스  이름
          - `get_hostid()`, `get_processid()`
      - 수신자
        - `wait_for_connection()`호출을 수행하고 연결이 이루어질 때 깨어남
        - `read_message()`, `write_message()`시스템 콜에 의해 메시지 교환
        - `close_connection()`호출은 통신을 종료
    - 공유 메모리 모델
      - 프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 `shared_memory_create()`, `shared_memory_attach()`시스템 콜 사용
        - race condition문제 조심해야 함
        - 대신 빠름
  - 보호
    - 컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법 지원
    - `set_permission()`, `get_permission()`
    - `allow_user()`, `deny_user()`
- c.f) 표준 C라이브러리
  - Unix, Linux를 위한 시스템 콜 인터페이스 제공
    - e.g) `printf()`는 내부적으로 `write()`시스템 콜이 불림

## 2.4 시스템 서비스

- 개요
  - 시스템 유틸리티이며, 프로그램 개발과 실행을 위해 더 편리한 환경을 제공
  - 몇몇은 단순히 시스템 콜에 대한 사용자 인터페이스, 나머지는 훨씬 더 복잡함
- 분류
  - 파일 관리
  - 상태 정보
    - 시스템 날짜, 시간, 사용 가능한 메모리, 디스크 공간의 양, 사용자 수 등
    - 로딩, 디버깅
    - 레지스트리
  - 파일 변경
  - 프로그래밍 언어 지원
    - C, C++, Java, Python에 대한 컴파일러, 어셈블러, 디버거 및 해석기
  - 프로그램 적재와 수행
    - absolute loader, relocate loader, linkage editor, overlay loader 등 제공
  - 통신
  - 백그라운드 서비스
    - 서비스(daemon)

## 2.5 링커와 로더

- 개요
  - 프로그램을 컴파일하고 메모리에 배치하여 사용 가능한 CPU 코어에서 실행할 수 있게 되기까지의 절차
- 순서
  - 컴파일러
    - 컴파일러가 소스코드를 오브젝트 파일로 컴파일
      - 재배치 가능 오브젝트 파일
    - `gcc -c main.c`
  - 링커
    - 링커가 재배치 가능 오브젝트 파일을 하나의 이진 실행파일로 결합
      - 표준 C 또는 수학 라이브러리와 같은 다른 오브젝트 파일 또는 라이브러리도 포함될 수 있음
    - `gcc -o main main.o -lm`
  - 로더
    - 로더는 이진 실행 파일을 메모리에 적재하는 데 사용됨
      - CPU 코어에서 실행할 수 있는 상태
    - `./main`
      - 셸이 `fork()`시스템 콜을 사용하여 프로그램을 실행하기 위한 새 프로세스 생성
      - `exec()`콜로 로더를 호출하고, `exec()`에 실행파일 이름을 전달
      - 로더가 새로 생성된 프로세스의 주소 공간을 사용하여, 지정된 프로그램을 메모리에 적재
        - == GUI의 더블클릭하면 유사한 매커니즘으로 로더 호출
    - c.f) DLL(Dynamically Linked Library)
      - 개요
        - 동적으로(런타임에) 링크되는 라이브러리
      - 장점
        - 여러 프로세스가 동적으로 링크된 라이브러리 공유하여, 메모리 사용 절약
        - 필요할때만 로드 가능함
- *ELF(Executable and Linkable Format)*
  - 개요
    - 오브젝트 파일 및 실행 파일의 표준화된 형식
      - 컴파일된 기계 코드 및 프로그램에서 참조되는 함수 및 변수에 대한 메타데이터 포함하는 기호 테이블 포함
  - 예시
    - 프로그램의 시작점
  - *정확히 무엇인가?*

## 2.6 응용 프로그램이 운영체제마다 다른 이유

일반적으로 특정 CPU 유형의 특정 운영체제에서 인터프리터, RTE 또는 이진 실행 파일을 작성하고 컴파일 하지 않으면 응용프로그램은 실행되지 않음

- 응용 프로그램을 다양한 운영체제에서 실행할 수 있게 하는 방법
  - 인터프리터 언어로 응용 프로그램 작성
    - e.g) Python, Ruby
  - 가상머신을 가진 언어로 개발
    - e.g) JAVA
  - 각 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API 사용
    - e.g) POSIX
- 응용 프로그램의 운영체제 마다 다른 이유
  - 각 운영체제에는 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 이진 형식이 있음
    - 운영체제 별로 다름
  - CPU는 다양한 명령어 집합을 가지며, 해당 명령어가 포함된 응용 프로그램만 올바르게 실행할 수 있음
  - 운영체제의 시스템 콜이 서로 다르기 때문

## 2.7 운영체제 설계 및 구현

- 개요
  - 해결하고자 하는 문제에 따라서 설계 및 구현이 다름
- OS 설계의 일반적인 원칙
  - 기법(Mechanisms)과 정책(Policies)의 분리
    - 기법은 How
    - 정책은 What
  - 구현(Implementation)
    - Portability over efficiency
      - 그렇기 때문에 C, C++과 같은 고급언어로 개발
      - 컴파일러가 알아서 잘 최적화 해줌
    - 병목은 자료구조나 알고리즘으로 해결하는 경우가 대부분
    - 성능이 중요한 부분
      - 인터럽트 핸들러
      - 입출력 관리자
      - 메모리 관리자
      - CPU 스케줄러

## 2.8 운영체제 구조

### 2.8.1 모놀리식 구조

- 개요
  - 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것
  - 일반적인 기술
  - tightly coupled
  - 예시
    - 리눅스
      - 단일 주소 공간에서 커널 모드로 전부 실행된다는 점에서는 모놀리식
      - 런타임 중에 커널을 수정할 수 있는 모듈식 설계
    - UNIX
    - Windows
- 장점
  - 속도와 효율성
    - 시스템 콜 인터페이스의 오버헤드가 거의 없음
    - 커널 안에서의 통신이 빠름
- 단점
  - 구현 및 확장이 힘듬

### 2.8.2 계층적 접근

- 개요
  - 기능이 특정 기능 및 한정된 기능을 가진 개별적이며 작은 구성요소를 합쳐 커널을 구성
  - 커널 전체가 계층적인 경우는 드물지만, 어느정도 운영체제는 계층화 함
    - 네트워크, 웹 응용 프로그램에서는 성공적으로 사용됨
    - 오버헤드 존재
- 방식
  - 계층적 접근방식
    - 최하위층 하드웨어, 최상위 층 사용자 인터페이스
    - 각 레이어는 자신의 하위층의 서비스와 기능들만을 사용하도록 선택
      - 시스템의 검증과 디버깅 단순화
      - 하부층부터 디버깅을 해서 문제가 있는 부분을 찾아내기 쉬움
- 장점
  - 한 구성요소의 변경이 다른 구성요소에는 영향을 미치지 않음
    - 자유로운 변경 가능

## 2.9 운영체제 빌딩과 부팅

## 2.10 운영체제 디버깅
