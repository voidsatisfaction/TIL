# 메모리 나누기 - 코드, 데이터, 스택, 힙

- 의문
- 12.0 개요
- 12.1 코드 및 데이터 세그먼트
- 12.2 스택 세그먼트
- 12.3 힙 세그먼트

## 의문

## 12.0 개요

- 메모리 세그먼트
  - 코드
    - 코드가 있는 메모리
  - 데이터
    - 프로그램 내내 없어지지 않는 전역 변수를 위한 공간
  - 스택
    - 함수 호출 등을 할 때마다 지역변수를 위해 런타임에 할당하는 메모리
  - 힙
    - 컴파일 타임에 데이터의 크기가 정해지지 않은 동적할당을 위한 메모리 세그먼트
- 주의
  - OS가 없는 임베디드 시스템에서 굳이 스택, 데이터 세그먼트 등을 나눌필요가 없음
  - 고급언어의 경우 세그먼테이션을 컴파일러가 알아서 해줌

## 12.1 코드 및 데이터 세그먼트

- 개요
  - 코드 세그먼트와 데이터 세그먼트는 논리적으로 분리되어 있음
    - 물리적으로는 분리되어있지 않으므로, 사실, 임의로 두 세그먼트를 나누지 않아도 됨
      - 그런데 알기 힘듬
- 코드 세그먼트
- 데이터 세그먼트
  - 프로그래머가 개념적으로 나누어 놓은, 데이터가 들어있는 메모리의 공간
  - 전역 변수가 들어감
- 프로그램 실행 후 동작
  - 프로그램 실행
  - 실행 파일의 이미지를 읽어 메모리에 로드
    - 코드 적재 & 데이터 세그먼트의 변수 초기화
    - 데이터 세그먼트의 어떤 부분을 어떤 값으로 초기화하라는 메타 데이터 형태로 값이 저장되어있음
      - 임베디드 펌웨어처럼 덩치가 작고, OS가 없는 경우에는, 바이너리 이미지가 데이터 및 코드 세그먼트 전체를 그대로 나타내는 경우가 대부분

## 12.2 스택 세그먼트

데이터 세그먼트와 스택 세그먼트 어셈블리어 차이

```c
#include "stdafx.h"
#include <stdio.h>

int global = 1;
// 이에 해당하는 어셈블리어는 존재하지 않음

int main(int argc, char* argv[])
{
  int local = global;
  // mov  eax, [global (00424a30)] (global변수의 경우, 프로그램 메모리에 로드할 때, 메모리에 직접 이니셜라이징)
  // mov  dword ptr [ebp-4], eax (dword는 32비트)

  // 여기서, ebp레지스터는 SP(스택 포인터)를 의미
  // -4인 이유는, 윈도우즈에서는 스택을 하위주소(큰 주소 값)에서 상위주소(작은 주소 값)로 증가되도록 만들었기 때문

  return 0;
}
```

- 전역변수
  - 개요
    - 프로그램 어디에서든 접근 가능한 변수
- 지역변수
  - 개요
    - 변수의 scope를 함수 안으로 제한적으로 하여, 독립성을 높인 변수
  - 원시적 구현 방법
    - 1 프로그램 내부의 함수의 개수마다, 고유한 데이터 세그먼트를 생성
      - 데이터를 너무 많이 차지하는 문제
    - 2 가장 메모리를 많이 차지하는 함수 하나만을 위한 공간을 확보하여 해당 공간 재활용
      - 함수 내부에서 또 다른 함수를 호출하는 경우의 문제
  - 현재의 구현 방법
    - stack저장 방식 활용
      - 스택 포인터(SP)
        - 스택 포인터는 초기에는 스택의 시작 부분의 주소를 가리킴
        - 함수 호출 시
          - 함수가 호출되면, 함수에 필요한 변수 크기만큼 스택에 매핑되고, SP가 그 크기만큼 조절됨
        - 함수 호출이 끝날 시
          - 콜리 함수가 끝나면, SP를 해당 콜리 함수가 할당되어 있던 만큼 감소시킴
        - 변수 접근
          - SP레지스터를 사용해, SP로부터 상대적인 거리를 이용해 변수를 엑세스
      - 장점
        - 1 동시에 여러 함수가 호출되는 상황이 발생해도, 서로의 변수 영역을 침범하지 않음
        - 2 모든 함수에 대해 미리 변수할당을 하지 않아서, 상당한 메모리 절약
        - 3 재귀호출 구현 가능
- 스택 세그먼트
  - 크기
    - 경험적으로 1MB정도의 영역

## 12.3 힙 세그먼트

- 개요
  - 컴파일 타임에 데이터의 크기가 정해지지 않은 동적할당을 위한 메모리 세그먼트
  - 힙을 관리하는 법은 OS나 컴파일러 등에 따라서 얼마든지 바뀔 수 있음
- 동작
  - 동적 할당 `malloc()`
    - 남은 힙 공간 중에 malloc함수를 부를 때 인자로 넘어오는 할당 크기만큼 연속된 공간이 존재하는지 탐색
    - 공간이 발견되면, 시작주소를 리턴
    - 리턴된 주소를 포인터로 선언된 변수에 저장하고 사용
  - 할당 해제 `free()`
    - 동적으로 할당된 메모리의 시작 주소를 넘겨 받아 그 공간을 다시 빈 공간으로 표시
      - 하지만 어떻게, 주소만 전달해줬는데 메모리의 크기와 같은 것들을 잘 맞춰서 해제해주는가?
        - 플랫폼, 컴파일러, OS마다 다른형태로 관리
        - 대표적인 방법은 메모리 자체에 필요한 정보를 보관(헤더정보 저장을 위한 더 큰 메모리 할당 요구)
- 구현
  - 링크드 리스트를 이용한 구현
    - 힙의 시작 주소를 프로그램내에 저장
    - 할당하는 메모리에 헤더를 저장
      - 할당된 메모리의 크기, 다음 할당된 메모리주소 포인터
- 참고
  - `new1`, `malloc`
    - 추상화 된 힙 메모리 할당 함수
    - 자체적으로 생성된 힙 공간 활용
    - 단편화 이슈가 존재
    - 일반적으로 이 API를 사용하는 것이 좋음
      - 호환성 등의 측면에서
  - `HeapAlloc`(윈도우즈 프로그래밍)
    - 힙 공간 자체를 지정 가능
    - 힙 공간을 자기가 만들고 그곳에 지정 가능
    - 단편화 이슈가 존재
  - `GlobalAlloc`, `LocalAlloc`
    - 자체적으로 생성된 힙 공간 활용
    - 리턴값이 메모리 주소가 아니라 핸들임
    - 메모리 lock이 필요함
      - OS가 단편화 작업을 수행하는것과 동시에 이루어지기 않기 위해서
  - `VirtualAlloc`
    - 가상 메모리 중에서 메모리 할당
      - 실제 메모리는 확보하지 않고, 논리적으로 해당 크기만큼 주소 공간을 예약함
    - 실제로 엑세스 하는 경우
      - `Commit`
    - 해제
      - `Decommit`
    - 논리적으로 큰 메모리가 필요하지만, 실제 엑세스는 좁은 영역에서 일어나는 경우에 유용
      - e.g) 엑셀
      - OS 스와핑보다 더 성능이 좋음
