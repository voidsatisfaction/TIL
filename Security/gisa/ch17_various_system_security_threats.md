# 17. 각종 시스템 보안위협 및 대응책

- 의문
- 17.1 버퍼 오버플로우 공격
  - 버퍼 오버플로우
  - 스택 버퍼 오버플로우
  - 힙 오버플로우
  - 버퍼 오버플로우 공격 대응
- 17.2 포맷 스트링 공격
  - 개요
  - 공격 원리
  - 포맷스트링 취약점의 위협요소
  - 보안 대책
- 17.3 레이스 컨디션 공격
  - 기본 개념
  - 심볼릭 링크와 레이스 컨디션 공격
  - 레이스 컨디션 공격에 대한 대응
- 17.4 백도어
  - 개요
  - 리눅스/유닉스 백도어
  - 백도어 탐지와 대응책
- 17.5 시스템 자원 고갈 공격(시스템 서비스 거부 공격)
  - 개요
  - 시스템 자원 고갈 공격(System Resource Exhaustion Attack)
- 17.6 리버스 엔지니어링
  - 기본 개념
  - 리버스 엔지니어링 공격
  - 리버스 엔지니어링에 대한 대응책
- 17.7 기타 시스템 보안위협 및 대응책
  - Rootkit
  - Logic bomb

## 의문

- *버퍼오버플로우 공격은 virtual memory(page)와는 상관이 없는 것인가?*
  - *프로그램은 virtual memory의 주소 체계를 따르지만, 결국에는 실제 memory위에 올라가있으므로 상관이 없는것?*

## 17.1 버퍼 오버플로우 공격

### 버퍼 오버플로우

- 프로세스 메모리 구조와 스택 프레임 구조
  - 프로세스 메모리 구조
    - Code
      - 프로그램 코드와 상수, 읽기전용 메모리 영역(데이터 저장하려고 하면, 분할충돌을 일으켜 프로세스 종료)
    - Data
      - 전역변수와 정적변수가 저장되어 있는 영역
    - Stack
      - 함수 인자 값, 함수 내의 지역 변수, 함수의 반환 주소 등이 저장되는 영역
      - 상위 메모리 주소에서 하위 메모리 주소로 데이터가 저장
    - Heap
      - 동적 메모리 호출에 의해 할당되는 메모리 영역
- 버퍼 오버플로우 공격의 기본 개념
  - 개요
    - 버퍼 또는 데이터 저장 영역에 할당된 용랴오다 더 많은 입력이 위치하면 다른 정보를 변경할 수 있는 조건
    - 이러한 조건을 이용하여, 시스템을 중지시키거나 시스템의 제어를 갖기 위한 특별한 코드 삽입
- 공격 원리

```c
int main(int argc, char *argv[]) {
  char buffer[10];
  strcpy(buffer, argv[1]); // strcpy 함수는 입력된 인수의 경계를 체크하지 않으므로, 인수는 buffer[10]으로 10바이트 길이를 넘지 않아야 하지만, 그보다 큰 인수를 받아도 스택에 쓰임
  print('%s\n', buffer);
}
```

### 스택 버퍼 오버플로우

- *스택의 개념에 대해서 다시 개념 정립하기*
- *다음의 시나리오는 참인지?*
  - 현재 실행되고있는 공격 대상 머신에 프로그램은 두가지
    - 버퍼오버플로우에 취약점이 있는 프로그램
    - 루트 권한으로 실행되고 있는 프로그램
  - 버퍼오버플로우에 취약점이 있는 프로그램을 이용해서, 루트 권한으로 실행되고 있는 프로그램의 함수 스택 반환 주소를 메모리상의 셸 코드 위치로 변환
  - 오염된 루트권한을 갖는 프로그램이 실행되면서, 셸 코드가 있는 메모리 주소를 실행하여 루트 권한 획득(셸코드는 삽입된 버퍼에 존재)

- 개요
  - 스택에 정해진 버퍼보다 큰 공격 코드를 삽입하여, 반환주소를 변경함으로써 임의의 공격 코드를 루트 권한으로 실행하도록 하는 방법
- 공격 대상
  - SetUID가 설정된 루트 권한의 프로그램
- 공격하기 위해 필요한 개념
  - 함수 호출 매커니즘
    - 개요
      - 함수가 다른 함수를 호출하면, 호출된 함수가 끝났을 때 제어를 반환할 수 있도록 반환 주소를 저장할 장소 필요
      - 호출된 함수가 반환될 떄 계속 사용할 레지스터 값을 저장할 장소가 필요
        - 이 모든 데이터는 stack frame이라 불리는 구조체 안의 스택에 저장
      - 호출된 함수 자체도 지역변수를 저장할 장소가 필요하며, 호출될 때마다 이 장소를 다른 위치로 하여 함수가 자기 자신을 직간접적으로 호출할 수 있도록 함
      - 재귀적 호출도 가능
  - shell code
    - 개요
      - 오버플로우가 발생하는 버퍼에 저장되는 공격자의 코드
        - 셸로 제어를 넘기고 공격당한 프로그램의 권한으로 시스템의 다른 프로그램에 접근하기 때문
- 스택 버퍼 오버플로우 공격 절차
  - 1단계
    - 공격 셸 코드를 버퍼에 저장
  - 2단계
    - 루트 권한으로 실행되는 프로그램의 특정 함수의 스택 반환주소 버퍼를 오버플로우 시켜서 공격 셸 코드가 저장되어 있는 버퍼의 주소로 덮어씌움
  - 3단계
    - 특정 함수의 호출이 완료되면 조작된 반환 주소로 셸 코드의 주소가 반환되어 셸 코드가 실행되고, 루트 권한을 획득하게 됨

### 힙 오버플로우

- 개요
  - 일반적으로 힙은 프로그램과 전역 데이터 위에 위치하며, 메모리 위 방향으로 커짐
    - 스택은 아래 방향으로 커짐
  - 힙에 요청되는 메모리는 레코드의 연결리스트와 같은 동적 데이터 구조를 위해 사용됨
    - 만약 이런 레코드가 오버플로우에 취약한 버퍼를 가지고 있다면, 연속된 메모리가 손상될 수 있음
  - 스택과는 다르게 실행 제어를 쉽게 이동시킬 수 있는 반환 주소는 없음
    - 그러나, 할당 공간에 함수에 대한 포인터를 포함하고 있다면, 공격자는 이 주소를 변경하여 겹쳐 쓴 버퍼에 있는 셸 코드를 가리키도록 할 수 있음

### 버퍼 오버플로우 공격 대응

- 개요
  - Compiletime 방어
  - Runtime 방어
- 분류
  - Compiletime 방어
    - 개요
      - 프로그램을 컴파일 할 때, 검사하여 버퍼 오버플로우를 방지하거나 발견
    - 방법
      - 고급 프로그래밍 언어 사용
        - JAVA, ADA, Python ...
          - 컴파일러가 범위 검사를 강제로 수행하는 코드를 자동으로 추가하므로, 명시적인 코딩이 필요 없음
      - 안전한 코딩 기법 도입
        - C, C++과 같은 메모리접근에 높은 자유도를 갖는 언어를 사용하는 경우, 입력되는 데이터의 크기가 할당된 버퍼의 크기를 초과하지 않도록 반드시 확인하는 로직을 포함해야 함
        - 사용 자제를 권장하는 함수
          - `strcat()`, `strcpy()`, `gets()`, `scanf()`, `sscanf()`, `vscanf()`, `vsscanf()`, `sprintf()`, `vsprintf()`, `gethostbyname()`, `realpath()`
        - 사용 권장 함수
          - `strncat()`, `strncpy()`, `fgets()`, `fscanf()`, `vfscanf()`, `snprintf()`, `vsnprintf()`
      - 스택 보호 매커니즘(Stack Guard)
        - 개요
          - 컴파일러가 프로그램의 함수 호출시에 `ret` 앞에 `canary`값을 주입하고, `return`시에 canary값이 변조되었는지의 여부를 확인하여 버퍼 오버플로우 공격을 탐지함
            - *`ret`앞이 어디임*
        - 문제
          - 기존 프로그램들을 모두 새로 컴파일 해야함
          - 스택 프레임의 구조가 변경되어 기존의 디버거들을 사용할 수 없는 문제가 생김
      - 스택 쉴드
        - 개요
          - 함수 시작 시 `return address`를 Global RET라는 특수 스택에 저장해 두었다가 함수 종료 시 저장된 값과 스택의 RET값을 비교해 다를 경우, 오버플로우로 가정하여 프로그램 실행 중단
  - Runtime 방어(OS level 방어)
    - 개요
      - 대부분의 Compiletime기법은 기존의 프로그램을 다시 컴파일 해야하므로, 기존의 취약한 프로그램에 보호를 제공하기 위하여 운영체제의 업데이트로 배포할 수 있는 Runtime 방어법이 인기를 끌고 있음
    - 방법
      - Executable Address Space Protection
        - 개요
          - 실행 코드가 프로세스 메모리상의 특정 위치에서만 실행될 수 있게 함으로써, 공격자가 스택 버퍼에 주입한 실행 코드(셸코드)를 원천적으로 실행될 수 없게 만듬
            - 스택과 힙을 Non-Executable Stack으로 만듬
        - rtl(return to libc) 공격
          - 스택에 있는 ret 주소를 실행 가능한 임의의 주소(libc 영역의 주소(메모리에 적재된 공유 라이브러리))로 돌려 원하는 함수를 수행하게 만듬
      - Address Space Layout Randomization(ASLR)
        - 개요
          - 스택 버퍼가 위치하는 주소 공간을 메모리 내에서 임의적으로 배치함으로써, 공격자가 스택 버퍼 속에 주입한 실행 코드의 주소를 예측할 수 없게 만듬
          - 실행 코드의 반환 주소 변경이 매루 어렵게 되어, 스택 버퍼 오버플로우 공격이 매우 어렵게 됨
        - NOP(No Operation) sled
          - 개요
            - NOP는 아무 기능도 수행하지 않는 명령어를 의미하고, 인텔 x86 시스템에서 사용하는데, 프로그램이 해당 명령어를 만나면 아무런 동작 없이 다음 명령어로 넘어감
            - 공격자는 셸코드 실행을 위해 NOP 명령을 셸 코드 앞에 삽입해서, 해당 영역을 가리키기만 하면 NOP를 타고 최종적으로 셀 코드가 실행되도록 함

## 17.2 포맷 스트링 공격

- *구체적을 어떻게 하는것인지?*

### 개요

- `printf()`, `fprintf()`, `sprintf()`와 같이 포맷스트링을 사용하는 함수를 사용하는 경우, 외부로부터 입력된 값을 검증하지 않고 이불력 함수의 포맷 문자열로 그대로 사용하는 경우 발생하는 취약점
- 공격자는 포맷 스트링을 이용하여 취약한 프로세스를 공격하거나 메모리 내용을 읽거나 쓸 수 있으며, 버퍼 오버플로우를 통해 임의의 코드를 실행하거나 데이터 표현에 관한 문제 일으킴

|파라미터|특징|파라미터|특징|
|------|---|-----|---|
|%d|integer|%o|양의 정수 8진수|
|%f|float|%x|양의 정수 16진수|
|%lf|double|%s|문자열|
|%s|문자 스트링(const)(unsigned)char*|%n|이전까지 출력한 총 바이트 수를 지정한 변수(4바이트 단위)에 저장|
|%u|unsigned integer|%hn|%n의 반인 2바이트 단위로 저장|

### 공격 원리

- 데이터 형태에 대한 불명확한 정의로 인한 것
  - 포맷 스트링을 인자로 하는 함수 사용 시 포맷 스트링을 지정하지 않고, 사용자 입력을 통해서 포맷 스트링이 결정된다면 공격자는 이를 조작하여 메모리 내용을 참조하고 특정 영역의 값을 변경할 수 있음
  - e.g)
    - `%x`를 통해 메모리 내용 참조 및 원하는 위치(RET영역)으로 이동한 후, `%n`을 통해 Return Address를 악성코드가 위치한 주소로 변조하여 악성코드 실행 가능

```c
// it's okay
#include <stdio.h>

int main(int argc, char **argv) {
  printf("%s", argv[1])
}

// not okay(vulnerable)
#include <stdio.h>

int main(int argc, char **argv) {
  printf(argv[1])
}
```

### 포맷스트링 취약점의 위협요소

- 프로그램 파괴
  - 프로세스를 죽게 만들 수 있음
    - core를 덤프하는 데몬을 죽이는 데 유용하게 사용됨
    - DNS 스푸핑을 할 때, 어떤 서비스가 반응하지 않도록 하는 데에 사용됨
- 프로세스 메모리 보기
  - 포맷 함수의 응답을 볼 수 있으면, 그것으로부터 유용한 정보를 수집할 수 있으며, 이 결과를 통해 포맷 스트링이 무엇을 하며 프로세스의 배치가 어떻게 생겼는지에 대한 개략적인 내용 획득 가능
- 임의의 메모리 덮어쓰기
  - 어떤 프로세스의 명령 통제권 장악 가능

### 보안 대책

- `printf()`, `snprintf()` 등 포맷문자열을 사용하는 함수에 사용자 입력값을 사용할 때는, 사용자가 포맷 스트링을 변경할 수 있는 구조로 쓰지 않음
- `%n`, `%hn`은 공격자가 이를 이용해 특정 메모리 위치에 특정값을 변경할 수 있으므로, 포맷 스트링 매개변수로 사용하지 않음
  - `%n`
    - 이전까지 출력한 총 바이트 수를 지정한 변수(4바이트 단위)에 저장
    - 즉, 값을 저장하는 용도로 사용되는 포맷 스트링
  - `%hn`
    - `%n`의 반인 2바이트 단위로 저장
- 시스템 패치를 꾸준히 함

## 17.3 레이스 컨디션 공격

*정확히 어떻게 passwd파일을 수정할 수 있는것인지?*

### 기본 개념

- 정의
  - 둘 이상의 프로세스나 스레드가 공유자원에 동시에 접근할 때, 접근하는 순서에 따라 비정상적인(원하지 않는) 결과가 발생하는 조건/상황
- 레이스 컨디션 공격 개요
  - 실행되는 관리자권한을 갖는 프로세스가 임시파일을 만드는 경우, 악의적인 프로그램을 통해 그 프로세스의 실행 중에 끼어들어, 임시파일을 목적파일로 연결(심볼릭 링크)하여 악의적인 행위를 하는 것
    - 특히 passwd 파일을 수정하는 경우가 많음

### 심볼릭 링크와 레이스 컨디션 공격

- 공격 대상
  - 소유자가 root고 SetUID 비트를 가지며, 임시 파일을 생성하는 파일(임시 파일의 이름을 알고 있어야 함)
    - 특정 파일에 접근하는 프로세스 목록은 `lsof`로 확인 가능
- 생성된 임시 파일을 확인하면, 임시 파일 이름으로 프로그램이 실행되기 전의 심볼릭 링크 파일을 생성
  - 해당 심볼릭 링크 파일은 관리자 권한으로만 접근 가능한 `/etc/passwd`를 가리킴

### 레이스 컨디션 공격에 대한 대응

- 프로그램 로직 중에서, 임시 파일을 생성한 후, 임시 파일에 접근하기 전에 임시 파일에 대한 심볼릭 링크 설정 여부와 권한에 대한 검사 과정을 추가
- 가능하면 임시 파일을 생성하지 않음
- unmask를 최하 022정도로 유지하여, 임시로 생성한 파일이 공격자에 의해 악의적으로 삭제되지 않도록 함

## 17.4 백도어

### 개요

- 정의
  - 시스템의 보안이 제거된 비밀 통로
    - 서비스 기술자나, 유지보수 프로그래머의 접근 편의를 위해서 설계자가 고의적으로 만들어둔 통로
    - 악의적으로 만들어진 통로도 있음
      - Back orifice
- 참고
  - 트랩도어
    - 복잡한 프로그램에서는 프로그램의 오류를 쉽게 발견할 수 있도록 특수한 접근 지점을 만들어 두는데, 이 접근 지점을 그대로 남겨둔 채 컴파일하게 되면, 완성된 프로그램에도 trap door가 존재하게 됨

### 리눅스/유닉스 백도어

- root 권한으로 운영되는 경우는, http 데몬이 시작 프로그램으로 자동 실행되거나 관리자가 보안에 관심이 없는 경우. root권한으로 운영되는 http 데몬은 보안에 매우 취약하기 떄문
- hrttp 데몬이 root 계정으로 운영되는 서버에 웹으로 접속하고 있을 때는, root 권한으로, nobody 권한으로 웹에 접속하고 있을 때는 nobody 권한으로 시스템에 자료를 요청하는 것

### 백도어 탐지와 대응책

- 현재 동작 중인 프로세스 확인
  - 정상 프로세스를 외워두자(특히 윈도우 프로세스)
  - 백도어가 애용하는 것은
    - `Csrss`, `Svchost`
- 알아두면 좋은 윈도우 프로세스
  - `Csrss.exe(Client/Server Runtime SubSystem: Win32)`
    - 윈도우 콘솔 관장, 스레드 생성/삭제, 32비트 가상 MS-DOS모드 지원
  - `Explorer.exe`
    - 작업 표시줄, 바탕 화면 같은 사용자 셸 지원 프로세스
  - `Lsass.exe(Local Security Authentication Server)`
    - Winlogon 서비스에 필요한 인증 프로세스를 담당하며, 인증 성공 시 초기 셸 실행
    - 사용자별 액세스 토큰 생성하여 다른 프로세스들이 해당 토큰 상속받게 함
  - `Mstask.exe(Window Task Scheduler)`
    - 시스템 백업, 업데이트 등에 관련된 작업 스케줄러 프로세스
  - `Smss.exe(Session Manager SubSystem)`
    - 사용자 세션 시작 기능을 담당하는 프로세스
    - Winlogon, Win32(Csrss.exe)를 구동하고, 시스템 변수를 설정. 정상적인 Winlogon, Csrss 종료시 시스템 종료
  - `Spoolsv.exe(Printer Spooler Service)`
    - 프린터와 팩스의 스풀링 기능을 담당하는 프로세스
      - *스풀링이란?*
  - `Svchost.exe(Service Host Process)`
    - DLL(Dynamic Link Libraries)에 의해 실행되는 프로세스의 기본 프로세스
    - 한 시스템에서 svchost 프로세스를 여러개 볼 수 있음
      - 윈도우의 서비스 프로그램을 그룹으로 묶어서 Svchost 프로세스에서 실행
  - `Services.exe(Service Control Manager)`
    - 시스템 서비스를 시작/정지하여 그들간의 상호작용을 하는 기능을 수행하는 프로세스
  - `Taskmgr.exe(Task Manager)`
    - Window 작업 관리자 자신의 프로세스
  - `Winlogon.exe(Windows Logon Process)`
    - 사용자 로그인/로그오프를 담당하는 프로세스
    - 윈도우 시작/종료시나 ctrl + alt + del 키를 눌렀을 때 활성화되는 프로세스
- H-IDS 사용
  - *이게뭐임?*

## 17.5 시스템 자원 고갈 공격(시스템 서비스 거부 공격)

### 개요

- 대부분의 시스템을 대상으로 하는 DoS(Denaial of Service)은 시스템이 보유하고 있는 자원을 선점하거나, 모두 고갈시키는 방식으로 수행
  - 디스크 채우기, 메모리 고갈, 모든 프로세스 죽이기, 포로세스 무한 생성

### 시스템 자원 고갈 공격(System Resource Exhaustion Attack)

- 가용 디스크 자원 고갈 공격

```c
#include <uinstd.h>
#include <sys/file.h>
void main() {
  int fd;
  char buf[1000];
  fd = creat("/root/temfile", 0777);
  while(1) write(fd, buf, sizeof(buf));
}
```

- 가용 메모리 자원 고갈 공격
  - 디스크 고갈 공격보다 시스템 자원을 더 많이 차지하여, 터미널 창 하나만 띄우는 데도 몇 분을 소모하게 만듬
    - *왜 메모리가 소비되면 터미널 창 띄우는데에 몇 분을 소모하게 만드는가?(스왑 메모리?)*

```c
#include <stdio.h>
void main() {
  char *m;
  while(1)
    m = malloc(1000);
}
```

- 가용 프로세스 자원 고갈 공격
  - `fork()` 라는 프로세스 할당 함수만 무한대로 씀
  - 당장 시스템 자원을 많이 차지하지는 않지만, 가용 프로세스가 꽉 차면 골치아픔
    - 운영체제를 다시 설치해야할 수도 있음

```c
#include <unistd.h>
void main() {
  while(1)
    fork();
  return 0;
}
```

- 프로세스 죽이기 공격
  - 공격자가 루트 권한을 획득한 상태에서, 스크립트를 통해 사용중인 프로세스 죽이는 방법

```c
#!/bin/sh
sync
kill -15 1
```

## 17.6 리버스 엔지니어링

### 기본 개념

- 정의
  - 장치나 시스템의 구조를 분석하여 원리를 발견하는 과정(역공학)

### 리버스 엔지니어링 공격

- 공격자는 리버스 엔지니어링을 통해 공격대상 시스템 또는 응용프로그램에 대한 분석 수행 가능
  - 시스템이나 응용프로그램이 갖고 있는 취약점 찾을 수 있음

### 리버스 엔지니어링에 대한 대응책

- 난독화
  - 소스코드 난독화
    - 개요
      - 소스코드를 알아보기 힘들게 만드는 기술
  - 바이너리 난독화
    - 개요
      - 컴파일 후 생성된 바이너리를 역공학을 통해 분석하기 어렵게 분해하는 기술

## 17.7 기타 시스템 보안위협 및 대응책

### Rootkit

- 정의
  - 시스템에 설치되어 그 존재의 흔적을 최대한도로 숨기면서 공격자가 언제든지 시스템에 관리자 권한으로 접근할 수 있도록 비밀 통로를 지속적으로 유지시켜주는 일련의 프로그램 집합
- 특징
  - 자신의 존재를 숨기기 위해서 시스템을 많이 변경하게 되는데, 사용자가 자신의 시스템에 루트킷이 들어와 있는지 혹은 루트킷이 어떤 변경을 했는지를 알기 매우 어렵게 만듬

### Logic bomb

- 정의
  - 특정한 사건이 발생할 때 프로그램이나 일련의 코드를 실행
- 예시
  - 네트워크 관리자가 해고될 떄, 기업의 전체 데이터베이스를 삭제하도록 프로그램된 논리 폭탄을 설치하고 설정 가능
  - 침해 시스템은 논리 폭탄이 설치되어 만약 forensics 활동이 실행되면, 논리 폭탄이 시작되어 모든 디지털 증거를 삭제하도록 할 수 있음
