# Linux

해당 책을 다 읽고 공룡책을 보면 좋을 듯 싶다.

- 의문
- 1\. 리눅스 빅 픽쳐
  - 1\.1 리눅스 시스템의 추상화 레벨과 레이어
  - 1\.2 하드웨어
  - 1\.3 커널
    - 역할
  - 1\.4 사용자 공간
  - 1\.5 사용자
- 2\. 기본 명령어와 디렉터리 계층 구조

## 의문

## 1. 리눅스 빅 픽쳐

### 1.1 리눅스 시스템의 추상화 레벨과 레이어

Linux abstraction level overview

![](./images/linux/ch1/linux_abstraction_level1.png)

- 레벨, 레이어
  - 해당 구성요소가 사용자와 하드웨어 사이의 어디에 위치하는지에 따라서 구성요소를 구분할 때의 단위
  - 예시
    - 웹 브라우저, 게임은 최상위 레이어
    - 하드웨어의 메모리, 0과 1은 최하위 레이어
    - 운영체제는 그 사이에 있는 대부분의 레이어
- 리눅스 시스템의 레이어
  - 사용자 프로세스
    - 프로세스는 사용자 공간(user space)라고 불리는 시스템의 상위 레벨 구성
    - 커널 vs 사용자 프로세스
      - 커널은 커널 모드에서 동작
      - 사용자 프로세스는 사용자 모드에서 동작
    - 사용자 모드
      - **사용자 공간**: 사용자 프로세스가 접근할 수 있는 주기억 공간의 일부 + 안전한 CPU 작업에만 접근 가능하게 제한
      - 예시
        - 웹 브라우저에 문제가 생겨도 백그라운드에서 돌아가던 딥러닝 모델 학습은 무사함
  - 커널
    - 운영체제의 핵심
    - 메모리 안에 존재
    - CPU가 해야 할 일이 무엇인지 전달
    - 하드웨어 관리
    - 커널 모드
      - 커널 모드에서 동작하는 코드는 프로세서나 주기억 장치에 제한 없이 접근 가능(아주 강력하고 위험)
      - **커널 공간**: 커널만이 접근할 수 있는 영역
  - 하드웨어
    - CPU, 메모리, 디스크, 네트워크 인터페이스

### 1.2 하드웨어

- 주기억 장치
  - 실행 중인 커널과 프로세스가 상주하는 공간이자, 커다란 비트의 집합체
- CPU
  - 명령들과 메모리의 데이터를 읽고 메모리에 다시 데이터를 기록

### 1.3 커널

- 커널
  - 거의 모든 작업이 주기억 장치를 위주로 진행
  - 메모리를 여러 개의 구획으로 분리 & 구획에 대한 상태(비트의 특정 배열) 정보를 항상 보유
  - 프로세스는 메모리에서 각자의 구획을 갖게 되고, 커널은 프로세스가 각자의 구획을 유지하는지 확인
- 작업 유지 임무
  - 프로세스
    - 어떤 프로세스가 CPU의 사용을 허용 받았는가 파악
  - 메모리
    - 모든 메모리를 지속적으로 파악
    - 현재 특정 프로세스에 할당된 메모리가 무엇인가 파악
    - 프로세스 간에 공유할 수 있는 메모리가 무엇인가 파악
    - 할당되지 않은 것은 무엇인가 파악
  - 장치 드라이버
    - 커널은 하드웨어와 프로세스 사이의 인터페이스로 동작
    - 하드웨어의 운영
  - 시스템 콜과 지원
    - **프로세스가 커널과 소통할 때, 시스템 콜을 사용**

#### 1.3.1 프로세스 관리

- 개요
  - 프로세스의 시작, 멈춤, 재개, 종료에 관한 것들
- 현대 운영체제
  - concurrency(context switch)
    - time slice가 매우 작게 나뉘어져있고, 주어진 작은 시간동안에 진행중인 작업을 마칠 수 있으므로 인간이 계속해서 context switching이 일어나는 지 인지하지 못함(multitasking)
- **커널이 동작하는 타이밍**
  - **타임 슬라이스 사이사이**
  - 커널은 context switch를 책임짐
  - 예시(context switch - 사용자 모드에서 실행되는 프로세스의 타임 슬라이스가 종료된 경우)
    - ① CPU는 내부 타이머를 기초로 하여 현재 프로세스를 중단하고 커널 모드로 전환(CPU 통제권을 커널에 넘김)
    - ② CPU와 메모리의 현재 상태를 기록
      - *CPU와 메모리의 현재 상태를 기록하면, 그 자원만큼 똑같은 크기의 공간을 준비해야 한다는 소리인가?*
      - *그리고 그 공간은 하드 디스크에 저장하는 것인가? 아니면 메모리의 다른 부분에 격리시키는 것인가?*
    - ③ *커널은 이전 타임 슬라이스 동안 발생해야 했던 작업들을 실행(입력과 풀력, I/O, 여러 활동들로부터 데이터를 수집하는 작업)*
      - *왜 이전 타임슬라이스에서 하지 않고, 커널모드가 됐을 때 작업하는 것인지?*
    - ④ 다른 프로세스가 동작할 수 있도록 준비. 커널이 실행할 준비가 된 프로세스 목록을 분석하고 하나 선택
    - ⑤ 새 프로세스를 위한 메모리 준비 및 CPU 준비(자원 준비)
    - ⑥ 새 프로세스를 위한 타임 슬라이스가 얼마나 걸릴 것인지 CPU에 보고
    - ⑦ 사용자 모드로 CPU를 전환하고, CPU 통제권을 프로세스에 넘김
  - *다수의 CPU를 갖고 있는 경우는 어떻게 스케쥴링되고, 커널은 어떤식으로 동작할까?*

#### 1.3.2 메모리 관리

- 개요
  - Context switch를 하는 동안 메모리를 관리하기 때문에, 매우 복잡한 작업 수행
- Context switch시에 커널의 조건
  - 사용자 프로세스가 접근할 수 없는 전용 영역을 메모리 안에 보유하고 있어야 함
  - 각 사용자 프로세스는 자신만의 메모리 구역이 있어야 함
  - 하나의 사용자 프로세스는 다른 프로세스의 전용 영역에 접근할 수 없음
  - 사용자 프로세스들은 메모리르 공유할 수 있음
  - 사용자 프로세스에서 일부 메모리는 읽기 전용이 될 수 있음
  - 시스템은 보조로 디스크 공간을 사용함으로써 물리적으로 존재하는 것보다 더 많은 메모리를 사용할 수 있음
- 현대의 CPU
  - 가상 메모리 라고 하는 메모리 관리 유닛(Memory Management Unit - MMU)을 포함
  - 가상 메모리
    - 프로세스는 직접 하드웨어 내의 물리적 위치로 메모리에 접근하지 않음
    - 프로세스가 머신 전체를 점유하고 있는 것처럼 동작하도록 해당 프로세스를 설정
    - 프로세스가 메모리 일정 부분에 접근할 때, MMU가 그 접근을 가로채서 memory address map을 사용하여, 프로세스의 메모리 위치를 머신상의 실질적인 물리적 메모리 위치로 변환
    - **커널은 memory address map을 초기화시키고, 지속적으로 유지하며 변경해야 함**
      - context switch가 이뤄지는 동안 이전 프로세스 맵으로부터 새로운 프로세스 맵으로 맵을 변경
      - memory address map을 구현하는 것을 **page table**이라 함

#### 1.3.3 장치 드라이버와 관리

- 개요
  - 장치는 커널 모드에서만 접근 가능
  - 장치 드라이버 관리
    - *장치 드라이버가 정확히 무엇인가?*

#### 1.3.4 시스템 콜과 지원

- 사용자 프로세스가 사용할 수 있는 커널의 몇가지 특징
  - 시스템 콜(사용자 프로세스와 커널 간의 상호작용)
    - e.g)
      - 파일 열고 읽고 쓰기
      - `fork()`
        - 프로세스가 호출하면 커널은 프로세스와 거의 일치하는 복사본을 만들어 냄
      - `exec()`
        - `exec(program)`을 호출하면, 커널은 program을 시작하여 현재 프로세스를 대신함
    - `ls`를 호출하면
      - shell이 `fork()`를 호출하여 shell의 복사본 생성
      - shell의 복사본이 `exec(ls)`를 호출
    - *커널에게 다른 프로세스를 생성하도록 요청하는 프로세스는 반드시 `fork()`시스템 호출을 실행해야 한다?*
      - python multiprocessing모듈의 start method 중에서 `spawn`은 무엇인지?
  - 의사 장치(pseudodevices)
    - 사용자 프로세스의 입장에서는 장치 처럼 보여지나, 순전히 소프트웨어로 구현되어 있음
    - 기술적으로는 커널에 있을 이유가 없으나, 실질적인 이유 때문에 커널에 존재
    - 시스템 콜을 사용해서 사용자 프로세스에서 접근 가능
    - e.g)
      - 난수 생성 장치(`/dev/random`)

### 1.4 사용자 공간

- 개요
  - 커널이 사용자 프로세스에게 할당하는 *주요 메모리(?)*
  - 실행중인 프로세스의 전체 메모리
  - 리눅스 시스템에서 대부분의 실제 동작은 사용자 공간에서 발생
    - 사용자 공간도 레벨이 존재

### 1.5 사용자

- 개요
  - 프로세스들을 실행할 수 있고 파일들을 소유할 수 있는 독립체
  - 커널은 userid 라고 하는 숫자로 구성된 식별자를 이용하여 사용자 인식
    - 사용자 이름과 다른 개념
  - 접근 권한과 한계를 설정
    - 모든 사용자 공간 프로세스는 `owner`라는 사용자를 갖고 있고, 프로세스들은 owner로서 실행 됨
    - 사용자는 다른 사용자의 프로세스를 방해할 수 없음
    - 사용자들은 파일을 소유할 수 있고, 다른 사용자들과 파일을 공유할 것인지 선택할 수 있음
- 종류
  - 루트(수퍼 사용자, 관리자)
    - 다른 사용자의 프로세스 종료 / 변경 가능 로컬 시스템상의 파일 읽을 수 있음
- 그룹
  - 다수의 사용자들로 구성된 집합
  - 그룹 내의 다른 사용자들과 파일 접근을 공유할 수 있음

## 2. 기본 명령어와 디렉터리 계층 구조
