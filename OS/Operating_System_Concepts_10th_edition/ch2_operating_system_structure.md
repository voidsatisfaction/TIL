# Ch2 운영체제 구조

- 의문
- 목표
- 2.1 운영체제 서비스
- 2.2 사용자와 운영체제 인터페이스
- 2.3 시스템 콜
- 2.4 시스템 서비스
- 2.5 링커와 로더
- 2.6 응용 프로그램이 운영체제마다 다른 이유
- 2.7 운영체제 설계 및 구현
- 2.8 운영체제 구조
- 2.9 운영체제 빌딩과 부팅
- 2.10 운영체제 디버깅

## 의문

## 목표

- 운영체제에서 제공하는 서비스 식별
  - 서비스를 제공하기 위해서 시스템 콜을 사용하는 방법
- 운영체제 설계
  - 모놀리식, 계층화, 마이크로 커널, 모듈 및 하이브리드 전략
- 운영체제 부팅 프로세스
- 운영체제 성능을 모니터링하기 위한 도구
- Linux 커널과 상호작용하기 위한 커널 모듈을 설계하고 구현

## 2.1 운영체제 서비스

- OS가 제공하는 사용자 친화적 서비스
  - UI
    - GUI
    - CLI
  - 프로그램 수행
  - 입출력 연산
  - 파일 시스템 조작
  - 통신
    - IPC
    - Network
  - 오류 탐지
- OS가 제공하는 시스템 자체의 효율적인 동작 보장 서비스
  - 자원 할당
    - CPU 스케줄링 등
  - logging
  - 보호와 보안

## 2.2 사용자와 운영체제 인터페이스

- CLI
  - 명령어 인터프리터가 실행할 명령어의 코드 자체를 갖고 있기 vs 실행할 명령어에 대응하는 프로그램의 위치만 알고 있기
    - Unix는 후자
    - 새로 명령어를 추가하기 용이
- GUI
  - 데스크톱
  - 터치스크린

## 2.3 시스템 콜

- 개요
  - 운영체제에 의해 사용가능하게 된 서비스에 대한 인터페이스 제공
  - 일반적으로 C, C++ 언어로 작성된 함수 형태로 제공
- 특징
  - 운영체제에 매개변수를 전달하기 위한 방법
    - 1 매개변수를 레지스터 내에 전달
    - 2 레지스터보다 매개변수가 많으면, 매개변수는 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달
    - 3 블록이나 스택을 사용
      - *블록은 뭐지?*
  - application 개발자는 시스템콜을 직접 사용하는것 보다, API에 따라 사용
    - e.g)
      - Windows API
      - POSIX API
      - Java API(JVM)
    - API를 사용하는 이유(시스템 콜을 직접 사용하지 않고)
      - 프로그램의 호환성
  - c.f) RTE(RunTime Environment)
    - 개요
      - 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는 데 필요한 전체 소프트웨어 제품군과 라이브러리 또는 로더와 같은 다른 소프트웨어를 함께 가리킴
      - 자체적으로 시스템 콜 인터페이스 제공
- 시스템 콜의 유형
  - 프로세스 제어
    - `fork()`
      - 새로 프로세스 생성
    - `exec()`
      - 프로그램을 메모리에 적재 후 실행
  - 파일 조작
    - `create()`, `delete()`, `open()`, `close()`
    - `read()`, `write()`
    - `get_file_attribute()`, `set_file_attribute()`
    - `move()`, `copy()`
    - 일부 시스템은 동일한 작업을 수행하는 시스템 프로그램을 제공하기도 함
  - 장치 조작
    - 주기억 장치, 디스크 드라이브, 파일에의 접근 등
      - *이것과 파일 조작의 차이는?*
    - 장치의 종류
      - 물리적 장치
        - 디스크 드라이브
      - 추상적 장치
        - 파일
    - 장치 사용 요청
      - `request(), release()`
      - `read(), write()`
  - 정보 유지 보수
    - 사용자 프로그램과 운영체제 간의 정보 전달
    - `time(), date()` 그 외에도 자유 메모리, 자유 디스크 공간과 같은 정보 알려줌
    - `dump()`
      - 디버깅에 좋음
    - `get_process_attribute(), set_process_attribute()`
  - 통신
    - 메시지 전달 모델
      - 통신하는 두 프로세스가 정보를 교환하기 위하여 서로 메시지를 주고받음
      - 연결이 열려 있어야 함
        - 상대 통신자에 대한 정보를 알아야 함
        - 호스트 이름과 프로세스  이름
          - `get_hostid()`, `get_processid()`
      - 수신자
        - `wait_for_connection()`호출을 수행하고 연결이 이루어질 때 깨어남
        - `read_message()`, `write_message()`시스템 콜에 의해 메시지 교환
        - `close_connection()`호출은 통신을 종료
    - 공유 메모리 모델
      - 프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 `shared_memory_create()`, `shared_memory_attach()`시스템 콜 사용
        - race condition문제 조심해야 함
        - 대신 빠름
  - 보호
    - 컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법 지원
    - `set_permission()`, `get_permission()`
    - `allow_user()`, `deny_user()`
- c.f) 표준 C라이브러리
  - Unix, Linux를 위한 시스템 콜 인터페이스 제공
    - e.g) `printf()`는 내부적으로 `write()`시스템 콜이 불림

## 2.4 시스템 서비스

## 2.5 링커와 로더

## 2.6 응용 프로그램이 운영체제마다 다른 이유

## 2.7 운영체제 설계 및 구현

## 2.8 운영체제 구조

## 2.9 운영체제 빌딩과 부팅

## 2.10 운영체제 디버깅
