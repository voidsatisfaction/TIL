# 스프링 입문을 위한 자바 객체 지향의 원리와 이해

- 의문
- Ch1. 사람을 사랑한 기술
  - 기술의 발달사
  - Java
  - Java Spring
- Ch2. 자바와 절차적 / 구조적 프로그래밍
- Ch3. 자바와 객체 지향
  - 객체 지향은 인간 지향
  - 객체 지향의 4대 특성
  - 추상화: 모델링

## 의문

- 오라클은 자바 언어와 VM에 대한 명세를 제공할 뿐이지, Oracle의 JVM등의 소프트웨어는 오픈 소스가 아니다
  - 그래서 어떻게 구현했는지는 모름
  - 명세: https://docs.oracle.com/javase/specs/index.html

## Ch1. 사람을 사랑한 기술

### 기술의 발달사

- 기계어
- 어셈블리어
  - 사람의 언어로 프로그래밍 가능
- C
  - One Source Multi Object Use Anywhere
- C++
  - C + OOP
- Java
  - Write Once Use Anywhere
  - OOP
- Java spring
  - 거대함 속의 단순함과 완벽함, 그리고 유연함
  - IoC/DI, AOP, PSA라는 객체 지향의 베스트 프랙티스만으로 아무리 거대한 프로그램이라도 쉽게 구현할 수 있음을 보여준 프레임워크

### Java

- 자바를 제대로 알려면 이해해야 할 것들
  - 객체 지향 4대 특성을 이해해야 함
    - 캡슐화
    - 상속
    - 추상화
    - 다형성
  - 또 알아야 할것
    - OOP 개념
    - 자바 언어의 문법
    - 자바가 OOP 개념을 구현한 방식

### Java Spring

- 개요
  - OOP 프레임 워크
- 자바 스프링을 제대로 알려면 이해해야 할 것들
  - 객체 지향
  - 프레임 워크
  - 스프링 삼각형
    - IoC/DI
    - AOP
    - PSA

## Ch2. 자바와 절차적 / 구조적 프로그래밍

### 자바 프로그램의 개발과 구동

- 현실세계 vs 자바세계
  - 소프트웨어 개발도구 - JDK
  - 운영체제 - JRE
  - 하드웨어(물리적 컴퓨터) - JVM
    - register가 아닌 stack기반의 머신
      - 그런데, android에서 네이티브로 사용하는 것은, 오라클의 JVM이 아니기도 하고, register기반이라고 함
- 자바 플랫폼
  - JDK
    - javac.exe(컴파일러) + JRE
  - JRE
    - java.exe(실행기, 인터프리터) + JVM

### 자바에 존재하는 절차적/구조적 프로그래밍의 유산

- 개요
  - goto대신 함수를 쓰자
    - goto는 실행 순서가 복잡해짐
    - 공유 사용에 문제가 쉽게 되는 전역 변수보다는 지역 변수 사용

자바코드 실행과 내부 동작 예시코드

```java
public class Start {
  public static void main(String[] args) {
    System.out.println("Hello OOP!!!");
  }
}
```

- 메모리 구조
  - Code
  - Data
    - Static
      - 클래스 멤버 변수
    - Stack
      - 지역 변수
    - Heap
      - 객체 맴버 변수
- 실행과 내부 동작
  - 1] JRE는 프로그램안에 `main()`메서드가 있는지 확인
  - 2] JVM은 목적 파일을 받아 그 목적 파일을 실행
  - 3] 전처리 시작
    - `java.lang`패키지를 스태틱 영역에 가져다 놓음
    - import한 패키지를 스태틱 영역에 가져다 놓음
    - 프로그램상의 모든 클래스를 스태틱 영역에 가져다 놓음
  - 4] 스택에 `main()`메서드의 스택 프레임을 할당
  - 5] 인자를 저장할 변수 공간을 변수 공간에 할당
  - 6] `main()`코드 실행
- 참고
  - 블록을 만나면 스택 프레임이 시작됨
  - 스택 프레임의 구조
    - 반환값을 저장할 변수 공간이 제일 아래
    - 그다음 인자를 저장할 변수 공간
    - 그다음으로 메서드의 지역 변수
- Call by value
  - 개요
    - 메서드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라, 변수가 저장한 값만을 복제해서 전달하는 것
      - 포인터를 전달해주는 것이 아님
      - 자바는 포인터가 없다

## Ch3. 자바와 객체 지향

### 객체 지향은 인간 지향

- 우리가 왜 기계 종속적인 개발을 해야하는가?
  - 포인터?
- 세계는 객체로 되어있다
  - 사람이 현실을 인지하는 방식
  - 세계의 객체를 분류(class)하라

### 객체 지향의 4대 특성

- 객체 지향의 4대 특성(캡상추다)
  - 캡슐화
  - 상속
  - 추상화
  - 다형성
- 클래스와 객체 메타포
  - 클래스는 분류
    - 객체를 총칭하는 개념
    - e.g)사람
  - 객체는 실체
    - 세상에 존재하는 유일무이한 사물
    - e.g) 김연아
  - 참고
    - 따라서, 붕어빵 - 붕어빵틀 비유는 잘못된 것
      - class에서 instance가 생성된다는 마테포만 반영된 것이고, 모델링의 본질에 대해서는 반영되지 않은 메타포

### 추상화: 모델링

- 추상화는 모델링이다
  - 개요
    - 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합 하는 것
  - IT용어 버전
    - **구체적인 것을 분해해서 관심 영역(application context)에 있는 특성만 가지고 재조합하는것 = 모델링**
- 객체와 클래스, 컨텍스트, 모델
  - 객체
    - 유일무이한 사물
  - 클래스
    - 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념
  - 컨텍스트
    - 애플리케이션 경계
    - "내가 창조하려는 세상은 어떤 세상인가?"
      - 컨텍스트에 따라서, 클래스의 설계가 달라져야 함(이름이라던지, 범위라던지)
  - 모델
    - 실제 사물을 목적에 맞게 관심 있는 특성만 추출해서 표현하는 것
      - = 추상화를 통해서 실제 사물을 단순하게 묘사하는 것(추상화의 결과물)
    - 자바언어에서는 모델이 곧 클래스
- 객체지향과 클래스 설계와의 관계
  - 사람이라는 클래스를 설계
  - 사람 객체를 관찰해서 사람 객체가 가진 공통된 특성을 찾게 됨
    - 속성: 시력, 몸무게, 혈액형, 키, 나이, 직업, 취미, ...
    - 행동: 먹다, 자다, 일하다, 침 뱉다, 운전하다, 울다, ...
- 자바에서의 추상화
  - 개요
    - 추상화 = 모델링 = 자바의 class 키워드
  - 넓은 의미의 추상화
    - 상속을 통한 추상화, 구체화
    - 인터페이스를 통한 추상화
    - 다형성을 통한 추상화
- 추상화 하는 절차
  - 애플리케이션 경계 설정
  - 객체의 관찰
  - 클래스 설계
    - 추상화(관심 있는 특성만 뽑아오자)
  - 추상화의 결과물은 모델, 모델은 자바 언어에서는 클래스로 표현

  추상화와 메모리

  ```java
  package abstraction01;

  public class Mouse {
    public String name;
    public int age;
    public static int countOfTail;

    public void sing() {
      System.out.println(name + " 찍찍!!!");
    }
  }

  public class MouseDriver {
    public static void main(String[] args) {
      // stack frame에 mickey변수가 로컬 변수로 들어가고, 그 값으로는 Mouse클래스의 객체가 들어있는 메모리의 주소(포인터)
      // 생성된 Mouse객체는 힙 메모리에 들어감
      // **굳이 힙이 아니어도 되지 않은가? 어차피 모든 필드가 크기가 정해져있는데**
      // String때문에 안되는건가? 그건 아닌거 같은데
      Mouse mickey = new Mouse();

      // 포인터를 사용한 필드에 값 할당
      mickey.name = "미키";
      mickey.age = 85;
      mickey.countOfTail = 1;

      mickey.sing();

      // mickey 포인터의 값을 null로 함
      // 생성된 인스턴스의 reference count가 0이므로 gc가 수거해감
      mickey = null;
    }
  }
  ```

  - 클래스 멤버
    - 정적 속성
      - 개요
        - 일반적으로 해당 클래스의 모든 객체들이 같은 값을 가질 때 사용
        - static segment의 메모리 공간 확보
      - 예시
        - 사람 클래스의 인구
        - 고양이 클래스의 다리 개수
        - 스용차 클래스의 바퀴 개수
    - 정적 메서드
      - 개요
        - main() 메서드
        - 클래스의 인스턴스를 만들지 않고 사용하게 되는 유틸리티성 메서드
          - e.g) Math
