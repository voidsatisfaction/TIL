# 오브젝트

- 의문
- 응용
- 각종 표현법
- 용어
  - 도메인
  - 메시지 vs 메서드
- 팁
- 개요
- 1 객체, 설계
  - 1.1 훌륭한 설계
  - 1.2 객체 지향 설계 원칙
  - 1.3 절차지향 vs 객체지향
- 2 객체지향 프로그래밍
  - 2.1 협력, 객체 클래스
  - 2.2 객체
  - 2.4 상속과 다형성
  - 2.5 추상화와 유연성

## 의문

## 응용

- business logics과 여타 로직의 분리?
  - service레이어에서 validation을 하지말자(Do.require)
    - 이미 그것은 controller level에서 끝내자
      - 그런데, 그렇게 되면, 같은 쿼리를 두번날려야하니까 비효율적?
      - 우리에게 최적화 보다는 생산성
      - 최적화는 나중에 생각해보자

## 각종 표현법

클래스 다이어그램

![](./images/class_diagram_example1.jpg)

- 연관관계
  - 협력을 위해 필요한 탐색 구조
    - 데이터 관점에서 참조 관계 구현(FK)
- 의존관계
  - 협력을 위해 일시적으로 필요한 의존성(파라미터, 리턴타입, 지연변수)
    - 의존성과 의존관계는 다름

## 용어

- 도메인
  - 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 메시지 vs 메서드
  - 메시지
    - 다른 객체와 상호작용할 때, 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청하기위한 매개체
      - e.g)
        - `Screening`이 `Movie`에게 `calculateMovieFee`메시지를 전송한다(o)
          - 메시지를 수신한 `Movie`가 스스로 적절한 메서드를 선택함
          - 메시지를 처리하는 방법은 `Movie`스스로의 문제
        - `Screening`이 `Movie`의 `calculateMovieFee`메서드를 호출한다(x)
  - 메서드
    - 수신된 메시지를 처리하기 위한 자신만의 방법

## 팁

- 2장 객체지향 프로그래밍
  - 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현
    - e.g) `Double`대신, `Money`타입
  - 협력의 관점에서 어떤 객체가 필요한지를 결정, 공통 상태와 행위를 구현하기 위해서 클래스를 작성

## 개요

**하지만 은총알은 없다**

- 패러다임
  - 개요
    - 한 시대의 사회 전체가 공유하는 이론과 방법, 문제의식 등의 체계
  - 예
    - 천동설, 지동설, 절차지향 프로그래밍, 객체지향 프로그래밍
- 프로그래밍 패러다임
  - 개요
    - 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 하는 것
      - 불필요한 의견 충돌 방지
      - 동일한 규칙과 방법을 공유하는 개발자로 성장
  - 특징
    - 언어가 어떤 패러다임을 지원하느냐에 따라서도 다름
  - 쿤의 패러다임과의 차이
    - 쿤
      - 상이한 두 패러다임은 함께 존재할 수 없음
      - 혁명적
    - 프로그래밍
      - 서로 다른 패러다임이 하나의 언어에서 공존할 수 있음
      - 발전적

## 1. 객체, 설계

절차지향 설계 vs 오브젝트 지향 설계

![](./images/procedural_vs_object_oriented1.jpg)

### 1.1 훌륭한 설계

**훌륭한 설계를 항상 머릿속에 염두해두면서 코드를 읽자**

- 개요
  - **1 기능을 온전히 수행 가능**
  - **2 쉽게 변경 가능(= 이해하기 쉬운 코드)**
    - 코드를 변경할 때 버그가 자주 발생하므로, 그것을 미연에 방지하는 것이 중요
  - **3 읽기 쉬운 코드**
- 특징
  - 훌륭한 설계는 적절한 트레이드오프의 결과물, 모두를 만족시키는 설계를 만들 수는 없다
- 방법
  - 개요
    - 훌륭한 설계를 실현하기 위한 다양한 방법이 존재할 수 있다
  - 종류
    - 절차지향적 방법
      - ...
    - 객체지향적 방법
      - 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써, 변경에 용이한 설계를 만드는 것
    - 함수형 방법
      - ...

### 1.2 객체 지향 설계 원칙

위의 훌륭한 설계를 '객체 지향' 패러다임에서 실현하기 위한 방법

**자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것**

- **1 자율성을 높이자**
  - 객체 자신이 자율성을 갖고 처리를 할 수 있게 변경
    - 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계
  - **객체지향의 세계에는 모든 것이 능동적이고 자율적인 존재(의인화)**
    - 소프트웨어를 생물로 생각하자. 모든 생물처럼 소프트웨어는 태어나고, 삶을 영위하고, 그리고 죽는다
- **2 캡슐화를 적극 도입하고, 응집도를 높이자**
  - 복잡한 의존성으로 인한 복잡도를 제어하기 위함
    - 의존성
      - 변경에 대한 영향(하나의 객체가 변경될 때, 그 객체에 의존하는 다른 객체도 함꼐 변경될 수 있음)
        - 변경에 취약한 코드의 원인
      - 의존성이 강하다 = 결합도가 높다
  - 캡슐화
    - 객체 내부의 상태를 감추고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것
      - 불필요한 의존성을 제거할 수 있음
      - 몰라도 되는 세부사항을 객체 내부로 감춤
  - 응집도
    - 밀접하게 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에 위임하는 객체를 가리켜, 응집도(cohesion)가 높다고 함
    - 객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 함
    - **외부 간섭을 최대한 배제** 하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길
- **3 적절한 객체에 적절한 책임을 할당**
  - 각 객체에 책임이 적절하게 분배되어야 함
    - 자신을 스스로 책임짐
    - 다른 객체와 협력함

### 1.3 절차지향 vs 객체지향

- 절차지향
  - 개요
    - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
    - 책임이 한곳에 집중
- 객체지향
  - 개요
    - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식
      - 단순화 한 정의

## 2. 객체지향 프로그래밍

- 객체지향이란 객체를 지향하는 것
  - 객체지향 패러다임의 중심에는 객체가 위치
  - 객체지향에서 가장 중요한 것은, 애플리케이션의 기능을 구현하기 위해 협력에 참여하는 개체들 사이의 상호작용
  - 객체들은 협력에 참여하기 위해 역할을 부여받고, 역할에 적합한 책임을 수행
- 객체지향 설계의 핵심
  - 적절한 협력을 식별
  - 협력에 필요한 역할을 정의
  - 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당
- 클래스 / 상속과 같은 프로그래밍 개념은 구현하는 그저 방법임

예시: 영화 예매

### 2.1 협력, 객체 클래스

- 객체지향 프로그래밍의 설계의 본질
  - 1 어떤 **객체** 들이 필요한지 고민
    - 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정
      - 클래스(x)
  - 2 객체를 독립적인 존재가 아니라, 기능을 구현하기 위해 **협력** 하는 공동체의 일원으로 보라
    - 객체를 협력에 참여하는 협력자로 바라봐야 함
  - 3 객체들을 타입으로 **분류** 하고, 이 타입을 바탕으로 클래스 구현

### 2.2 객체

- 객체에 대한 객체지향에서의 개요
  - 1 **상태와 행동** 을 가지는 복합적인 존재
  - 2 객체가 스스로 판단하고 행동하는 **자율적인 존재**
    - 무생물도 객체지향 패러다임에서는 자율적인 존재로 간주
  - 3 **캡슐화**
    - **객체라는 단위 안에, 데이터와 기능을 한 덩어리로 묶음으로써, 문제 영역의 아이디어를 적절하게 표현할 수 있게 하는 것**
      - 절차 지향에서는, 데이터와 기능이라는 독립적인 존재로 엮어서 프로그램을 구성
    - 접근 제어 메커니즘 제공
      - 접근을 통제하는 이유는, **객체를 자율적인 존재로 만들기 위함**
        - **외부 간섭 최소화**
- 객체 협력
  - 객체끼리 상호작용하는 유일한 방법은, **메시지를 전송** 하는 것 뿐
  - 메서드
    - 수신된 메시지를 처리하기 위한 자신만의 방법
  - c.f) 메시지 vs 메서드
    - 메시지 != 메서드

### 2.4 상속과 다형성

- 유연한 설계의 트레이드 오프
  - 설계가 유연 => 코드를 이해하고 디버깅하기는 점점 더어려워짐
  - 유연성을 억제 => 코드를 이해하고 디버깅하기 쉬워짐
- 상속
  - 개요
    - 클래스를 하나 추가하고 싶은데, 그 클래스가 기존의 어떤 클래스와 매우 흡사한 경우
    - 재사용해서 새로운 클래스를 만들면 좋음
    - 그것을 가능하게 해주는 방법이 상속
      - 코드의 공유
  - 특징
    - **차이에 의한 프로그래밍**
      - 부모클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
  - 진정한 가치
    - **부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있음**
      - 인터페이스는 객체가 이해할 수 있는 메시지의 목록
      - 인터페이스 상속을 위해 사용해야 함
  - 단점
    - 캡슐화를 위반
      - 부모클래스의 구현이 자식 클래스에게 노출
        - 부모클래스의 변경시, 자식 클래스도 함께 변경될 확률이 높아짐
    - 설계를 유연하지 못하게 만듬
      - 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정
        - 런타임에 객체의 종류 변경 불가
  - 업캐스팅
    - 개요
      - 자식 클래스가 부모 클래스를 대신하는 것
- 다형성
  - 개요
    - 동일한 메시지를 전송하지만, 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 다른 것
    - 동일한 메시지를 수신했을 때, 객체의 타입에 따라 다르게 응답할 수 있는 능력
  - 구현
    - 지연 바인딩(동적 바인딩)
      - 실행 시점에 메시지와 메서드를 바인딩하는 것
    - vs 초기 바인딩(정적 바인딩)
      - 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것

### 2.5 추상화와 유연성

- 추상화
  - 장점
    - **상위 정책을 쉽고 간단하게 표현 가능**
      - e.g) 영화 예매 요금은, 최대 하나의 할인 정책과 다수의 할인 조건을 이용해 계산할 수 있다
      - 기본적인 애플리케이션의 협력 흐름을 기술한다는 것
        - 디자인 패턴, 프레임워크 모두 상위 정책을 정의하는 객체지향의 매커니즘을 따름
    - **기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있음**
        - e.g) 영화 예매시, `NonDiscountPolicy`를 추가해서 아에 할인이 없는 영화 생성 가능
  - **모든건 트레이드 오프**
