# 오브젝트

- 의문
- 응용
- 각종 표현법
- 용어
  - 도메인
  - 메시지 vs 메서드
- 팁
- 개요
- 1 객체, 설계
  - 1.1 모듈의 목적
  - 1.2 객체 지향 설계 원칙
  - 1.3 변경에 취약한 코드
  - 1.4 절차지향 vs 객체지향
- 2 객체지향 프로그래밍
  - 2.1 협력, 객체 클래스
  - 2.2 객체

## 의문

## 응용

- business logics과 여타 로직의 분리?
  - service레이어에서 validation을 하지말자(Do.require)
    - 이미 그것은 controller level에서 끝내자
      - 그런데, 그렇게 되면, 같은 쿼리를 두번날려야하니까 비효율적?
      - 우리에게 최적화 보다는 생산성
      - 최적화는 나중에 생각해보자

## 각종 표현법

클래스 다이어그램

![](./images/class_diagram_example1.jpg)

- 연관관계
  - 협력을 위해 필요한 탐색 구조
    - 데이터 관점에서 참조 관계 구현(FK)
- 의존관계
  - 협력을 위해 일시적으로 필요한 의존성(파라미터, 리턴타입, 지연변수)
    - 의존성과 의존관계는 다름

## 용어

- 도메인
  - 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 메시지 vs 메서드
  - 메시지
    - 다른 객체와 상호작용할 때, 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청하기위한 매개체
      - e.g)
        - `Screening`이 `Movie`에게 `calculateMovieFee`메시지를 전송한다(o)
          - 메시지를 수신한 `Movie`가 스스로 적절한 메서드를 선택함
          - 메시지를 처리하는 방법은 `Movie`스스로의 문제
        - `Screening`이 `Movie`의 `calculateMovieFee`메서드를 호출한다(x)
  - 메서드
    - 수신된 메시지를 처리하기 위한 자신만의 방법

## 팁

- 2장 객체지향 프로그래밍
  - 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현
    - e.g) `Double`대신, `Money`타입
  - 협력의 관점에서 어떤 객체가 필요한지를 결정, 공통 상태와 행위를 구현하기 위해서 클래스를 작성

## 개요

**하지만 은총알은 없다**

- 패러다임
  - 개요
    - 한 시대의 사회 전체가 공유하는 이론과 방법, 문제의식 등의 체계
  - 예
    - 천동설, 지동설, 절차지향 프로그래밍, 객체지향 프로그래밍
- 프로그래밍 패러다임
  - 개요
    - 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 하는 것
      - 불필요한 의견 충돌 방지
      - 동일한 규칙과 방법을 공유하는 개발자로 성장
  - 특징
    - 언어가 어떤 패러다임을 지원하느냐에 따라서도 다름
  - 쿤의 패러다임과의 차이
    - 쿤
      - 상이한 두 패러다임은 함께 존재할 수 없음
      - 혁명적
    - 프로그래밍
      - 서로 다른 패러다임이 하나의 언어에서 공존할 수 있음
      - 발전적

## 1. 객체, 설계

절차지향 설계 vs 오브젝트 지향 설계

![](./images/procedural_vs_object_oriented1.jpg)

- 훌륭한 설계
  - 개요
    - 기능을 온전히 수행 가능
    - 쉽게 변경 가능(= 이해하기 쉬운 코드)
      - 코드를 변경할 때 버그가 자주 발생하므로, 그것을 미연에 방지하는 것이 중요
  - 특징
    - 훌륭한 설계는 적절한 트레이드오프의 결과물, 모두를 만족시키는 설계를 만들 수는 없다
  - 방법
    - 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써, 변경에 용이한 설계를 만드는 것

### 1.1 모듈의 목적

**모듈의 목적을 항상 머릿속에 염두해두면서 코드를 읽자**

- 1 실행 중에 제대로 동작하는 것
- 2 변경을 위해 존재하는 것
  - 모듈이 변경하기 쉬워야 함
- 3 코드를 읽는 사람과 의사소통 하는 것

### 1.2 객체 지향 설계 원칙

**자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것**

- **자율성을 높이자**
  - 객체 자신이 자율성을 갖고 처리를 할 수 있게 변경
    - 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계
- **캡슐화와 응집도**
  - 캡슐화
    - 객체 내부의 상태를 감추고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것
  - 응집도
    - 밀접하게 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에 위임하는 객체를 가리켜, 응집도(cohesion)가 높다고 함
    - 객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 함
    - 외부 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길
- **적절한 객체에 적절한 책임을 할당**
  - 각 객체에 책임이 적절하게 분배되어야 함
    - 자신을 스스로 책임짐
    - 다른 객체와 협력함
- **객체지향의 세계에는 모든 것이 능동적이고 자율적인 존재(의인화)**
  - 소프트웨어를 생물로 생각하자. 모든 생물처럼 소프트웨어는 태어나고, 삶을 영위하고, 그리고 죽는다

### 1.3 변경에 취약한 코드

- 문제 해결의 핵심
  - 애플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고, 불필요한 의존성을 제거하는게 핵심
    - 의존성 제거 방법
      - 객체가 몰라도 되는 세부사항을 다른 객체 내부로 **캡슐화** 하여 감춤
        - 자율성을 높임
        - 응집도 높은 객체들의 공동체 창조
    - 의존성(dependency)
      - 변경에 대한 영향을 암시
        - 어떤 객체가 변경될 떄 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있음
- 의존성이 강한 경우
  - 결합도(coupling)가 높다
    - 결합도는 의존성과 관련이 높음

### 1.4 절차지향 vs 객체지향

- 절차지향
  - 개요
    - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
    - 책임이 한곳에 집중
- 객체지향
  - 개요
    - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식
      - 단순화 한 정의

## 2. 객체지향 프로그래밍

예시: 영화 예매

### 2.1 협력, 객체 클래스

- 객체지향 프로그래밍의 설계의 본질
  - 1 어떤 **객체** 들이 필요한지 고민
    - 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정
      - 클래스(x)
  - 2 객체를 독립적인 존재가 아니라, 기능을 구현하기 위해 **협력** 하는 공동체의 일원으로 보라
    - 객체를 협력에 참여하는 협력자로 바라봐야 함
  - 3 객체들을 타입으로 **분류** 하고, 이 타입을 바탕으로 클래스 구현

### 2.2 객체

- 객체에 대한 객체지향에서의 개요
  - 1 **상태와 행동** 을 가지는 복합적인 존재
  - 2 객체가 스스로 판단하고 행동하는 **자율적인 존재**
    - 무생물도 객체지향 패러다임에서는 자율적인 존재로 간주
  - 3 **캡슐화**
    - **객체라는 단위 안에, 데이터와 기능을 한 덩어리로 묶음으로써, 문제 영역의 아이디어를 적절하게 표현할 수 있게 하는 것**
      - 절차 지향에서는, 데이터와 기능이라는 독립적인 존재로 엮어서 프로그램을 구성
    - 접근 제어 메커니즘 제공
      - 접근을 통제하는 이유는, **객체를 자율적인 존재로 만들기 위함**
        - **외부 간섭 최소화**
- 객체 협력
  - 객체끼리 상호작용하는 유일한 방법은, **메시지를 전송** 하는 것 뿐
  - 메서드
    - 수신된 메시지를 처리하기 위한 자신만의 방법
