# 오브젝트

- 의문
- 개요
- 1 객체, 설계
  - 1.1 모듈의 목적
  - 1.2 객체 지향 설계 원칙
  - 1.3 변경에 취약한 코드
  - 1.4 절차지향 vs 객체지향

## 적용

- business logics과 여타 로직의 분리?
  - service레이어에서 validation을 하지말자(Do.require)
    - 이미 그것은 controller level에서 끝내자
      - 그런데, 그렇게 되면, 같은 쿼리를 두번날려야하니까 비효율적?
      - 우리에게 최적화 보다는 생산성
      - 최적화는 나중에 생각해보자

## 의문

## 개요

**하지만 은총알은 없다**

- 패러다임
  - 개요
    - 한 시대의 사회 전체가 공유하는 이론과 방법, 문제의식 등의 체계
  - 예
    - 천동설, 지동설, 절차지향 프로그래밍, 객체지향 프로그래밍
- 프로그래밍 패러다임
  - 개요
    - 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 하는 것
      - 불필요한 의견 충돌 방지
      - 동일한 규칙과 방법을 공유하는 개발자로 성장
  - 특징
    - 언어가 어떤 패러다임을 지원하느냐에 따라서도 다름
  - 쿤의 패러다임과의 차이
    - 쿤
      - 상이한 두 패러다임은 함께 존재할 수 없음
      - 혁명적
    - 프로그래밍
      - 서로 다른 패러다임이 하나의 언어에서 공존할 수 있음
      - 발전적

## 1. 객체, 설계

### 1.1 모듈의 목적

- 1] 실행 중에 제대로 동작하는 것
- 2] 변경을 위해 존재하는 것
  - 모듈이 변경하기 쉬워야 함
- 3] 코드를 읽는 사람과 의사소통 하는 것

### 1.2 객체 지향 설계 원칙

- **자율성을 높이자**
  - 객체 자신이 자율성을 갖고 처리를 할 수 있게 변경
- **캡슐화와 응집도**
  - 캡슐화
    - 객체 내부의 상태를 감추고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것
  - 응집도
    - 밀접하게 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에 위임하는 객체를 가리켜, 응집도(cohesion)가 높다고 함
    - 객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 함
    - 외부 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길

### 1.3 변경에 취약한 코드

- 문제 해결의 핵심
  - 애플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고, 불필요한 의존성을 제거하는게 핵심
    - 의존성(dependency)
      - 변경에 대한 영향을 암시
        - 어떤 객체가 변경될 떄 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있음
- 의존성이 강한 경우
  - 결합도(coupling)가 높다
    - 결합도는 의존성과 관련이 높음

### 1.4 절차지향 vs 객체지향

- 절차지향
  - 개요
    - 프로세스와 데이터를 별도의 모듈에 위치시키는 방식
    - 책임이 한곳에 집중
- 객체지향
  - 개요
    - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식
