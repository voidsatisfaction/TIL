# 하테나에서 근무하면서 깨달은 기술적인 사실

## 상태와 무상태성(state, stateless)

Go언어나 여타 오브젝트지향 언어로 프로그래밍을 하다보면, 디자인 패턴으로 `constructor`패턴을 많이 사용하게 됨. 그러나 정말 `constructor`패턴이 필요한가?에 대한 의문을 갖을 필요가 있음.

`constructor`패턴을 사용해서 인스턴스를 초기화 한다는 것의 의미 중 하나는, 그 인스턴스가 **상태** 를 갖는 것과 동등한 말이다. 즉, 상태가 필요 없는 행위(데이터 베이스에서 단순히 값을 가져옴, 외부 서버에 리소스 요청 등)를 할 때에는 굳이 상태를 갖을 필요가 없으며, 오히려 상태를 갖음으로 인해서 프로그래밍의 복잡도를 증가시킬 수 있다.

예를들면 데이터 베이스나 다른 API서버에서 데이터를 갖고오는 행위는 단순히 데이터만 갖고 오기 때문에 상태가 굳이 필요하지 않다.

사실 컴퓨터과학에서의 논리게이트에도 상태와 무상태성을 구분된다. 플립 플롭이나 레지스터는 상태를 갖는 순차 논리이다. 하지만, 단순 논리 연산 `OR AND NAND`혹은 `ALU`등은 상태를 갖지 않는 조합 논리이다. 이는 또, 오토마톤과 튜링머신으로 이야기가 이어지는데 이는 나중에 공부해보고 싶은 테마이기도 하다.

함수형 프로그래밍은 상태를 되도록 적게 가지려는 프로그래밍 패러다임이라고 할 수 있다. 함수형 프로그래밍은 상태를 적게 갖기 때문에 순수함수적 성격(부작용이 없음)을 띄고 있으며, 테스트하기 쉬운 특징이 있다.

## 1차원 추상화, 2차원 추상화, 다차원 추상화

- MVC프레임웍의 추상화와 nand-to-tetris의 추상화의 차이
  - nand-to-tetris에 있어서의 추상화는 일차원적임.
    - 고수준 언어 => 바이트 코드 => 어셈블리어 => 기계어 => CPU/Memory => Register => 논리게이트
  - MVC프레임웍 같은 경우는 컨트롤러가 모델 덩어리(내부는 추상화 되어있음)와 뷰 덩어리(내부는 추상화 되어있음)를 중제해주는 역할이다.
    - 컨트롤러 => 부모뷰 => 자식뷰 => 자식뷰 ...
    - 컨트롤러 => 모델(외부서버?) => ...
- 컴퓨터 과학의 거의 대부분의 복잡도 문제는 레이어를 하나 더 추가하는 것으로 해결 가능하다.
- Small is Beautiful
- Make program one thing well
- **Unix사상!!**

## 프록시

- 하테나와 프록시
  - 포워드 프록시
    - 요청을 보내는 쪽에서 모든 응답에 대해서 결과를 캐시해두는 프록시
  - 리버스 프록시
    - 요청을 받는 쪽에서 자신에 대한 요청으로 부터의 특정 응답의 결과를 캐시해두는 프록시
  - 프록시는 캐시의 기능으로 많이 사용 / 아이피 세탁
  - 프록시 서버는 리퀘스트데이터를 보존하고 그 리퀘스트 데이터에 매칭하는 리스폰스를 캐시해서 돌려줌(심볼 테이블 같은 느낌)

## 반드시 공부하자 리스트

하테나 코드의 어디를 봐도 항상 있는 두 친구들이 있다.

- 정규 표현식(regex)
  - [생활코딩 - 정규표현식](https://opentutorials.org/course/909/5142)
- 쉘 스크립트(shell script)

정말 진짜 너무나도 유용한 친구들이지만 너무나도 잘 모르는 친구들인데 꼭 시간내서 공부하는게 좋을 것 같다. 주말에 부트캠프처럼 공부하는 것도!

## 어떠한 레이어에 어떠한 처리를 할지 생각하자

- 결국 레이어를 나누는 것은 책임을 분담하는 것
- 하나의 레이어가 여러가지 책임을 갖고 있으면 관리하기 어려움

## 메서드나 변수의 이름은 알기 쉽게 해놓자. 너무 길게는 말고

- 김춘수 시인의 시 **꽃**
